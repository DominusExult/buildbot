Index: acinclude.m4
===================================================================
--- acinclude.m4	(revision 4281)
+++ acinclude.m4	(working copy)
@@ -1,164 +1,147 @@
-dnl AM_PATH_SDL([MINIMUM-VERSION, [ACTION-IF-FOUND [, ACTION-IF-NOT-FOUND]]])
-dnl Test for SDL, and define SDL_CFLAGS and SDL_LIBS
-dnl
-AC_DEFUN([AM_PATH_SDL],
-[dnl 
-dnl Get the cflags and libraries from the sdl-config script
-dnl
-AC_ARG_WITH(sdl-prefix,[  --with-sdl-prefix=PFX   Prefix where SDL is installed (optional)],
-            sdl_prefix="$withval", sdl_prefix="")
-AC_ARG_WITH(sdl-exec-prefix,[  --with-sdl-exec-prefix=PFX Exec prefix where SDL is installed (optional)],
-            sdl_exec_prefix="$withval", sdl_exec_prefix="")
-AC_ARG_ENABLE(sdltest, [  --disable-sdltest       Do not try to compile and run a test SDL program],
-		    , enable_sdltest=yes)
+dnl Check if we have SDL (sdl-config, header and library) version >= 1.2.0
+dnl Extra options: --with-sdl-prefix=PATH and --with-sdl={sdl12,sdl2}
+dnl Output:
+dnl SDL_CFLAGS and SDL_LIBS are set and AC_SUBST-ed
+dnl HAVE_SDL_H is AC_DEFINE-d
 
+AC_DEFUN([EXULT_CHECK_SDL],[
+  exult_backupcppflags="$CPPFLAGS"
+  exult_backupldflags="$LDFLAGS"
+  exult_backuplibs="$LIBS"
+
+  exult_sdlok=yes
+
+  AC_ARG_WITH(sdl-prefix,[  --with-sdl-prefix=PFX   Prefix where SDL is installed (optional)], sdl_prefix="$withval", sdl_prefix="")
+  AC_ARG_WITH(sdl-exec-prefix,[  --with-sdl-exec-prefix=PFX Exec prefix where SDL is installed (optional)], sdl_exec_prefix="$withval", sdl_exec_prefix="")
+  AC_ARG_WITH(sdl,       [  --with-sdl=sdl12,sdl2   Select a specific version of SDL to use (optional)], sdl_ver="$withval", sdl_ver="")
+
+  dnl First: find sdl-config or sdl2-config
+  exult_extra_path=$prefix/bin:$prefix/usr/bin
+  sdl_args=""
   if test x$sdl_exec_prefix != x ; then
      sdl_args="$sdl_args --exec-prefix=$sdl_exec_prefix"
-     if test x${SDL_CONFIG+set} != xset ; then
-        SDL_CONFIG=$sdl_exec_prefix/bin/sdl-config
-     fi
+     exult_extra_path=$sdl_exec_prefix/bin
   fi
   if test x$sdl_prefix != x ; then
      sdl_args="$sdl_args --prefix=$sdl_prefix"
-     if test x${SDL_CONFIG+set} != xset ; then
-        SDL_CONFIG=$sdl_prefix/bin/sdl-config
-     fi
+     exult_extra_path=$sdl_prefix/bin
   fi
-
-  AC_PATH_PROG(SDL_CONFIG, sdl-config, no)
-  min_sdl_version=ifelse([$1], ,0.11.0,$1)
-  AC_MSG_CHECKING(for SDL - version >= $min_sdl_version)
-  no_sdl=""
+  if test x"$sdl_ver" = xsdl12 ; then
+    exult_sdl_progs=sdl-config
+  elif test x"$sdl_ver" = xsdl2 ; then
+    exult_sdl_progs=sdl2-config
+  else
+    dnl NB: This line implies we prefer SDL 1.2 to SDL 2.0
+    exult_sdl_progs="sdl-config sdl2-config"
+  fi
+  AC_PATH_PROGS(SDL_CONFIG, $exult_sdl_progs, no, [$exult_extra_path:$PATH])
   if test "$SDL_CONFIG" = "no" ; then
-    no_sdl=yes
+    exult_sdlok=no
   else
-    SDL_CFLAGS=`$SDL_CONFIG $sdlconf_args --cflags`
-    SDL_LIBS=`$SDL_CONFIG $sdlconf_args --libs`
+    SDL_CFLAGS=`$SDL_CONFIG $sdl_args --cflags`
+    SDL_LIBS=`$SDL_CONFIG $sdl_args --libs`
 
     sdl_major_version=`$SDL_CONFIG $sdl_args --version | \
            sed 's/\([[0-9]]*\).\([[0-9]]*\).\([[0-9]]*\)/\1/'`
     sdl_minor_version=`$SDL_CONFIG $sdl_args --version | \
            sed 's/\([[0-9]]*\).\([[0-9]]*\).\([[0-9]]*\)/\2/'`
-    sdl_micro_version=`$SDL_CONFIG $sdl_config_args --version | \
+    sdl_patchlevel=`$SDL_CONFIG $sdl_args --version | \
            sed 's/\([[0-9]]*\).\([[0-9]]*\).\([[0-9]]*\)/\3/'`
-    if test "x$enable_sdltest" = "xyes" ; then
-      ac_save_CFLAGS="$CFLAGS"
-      ac_save_LIBS="$LIBS"
-      CFLAGS="$CFLAGS $SDL_CFLAGS"
-      LIBS="$LIBS $SDL_LIBS"
-dnl
-dnl Now check if the installed SDL is sufficiently new. (Also sanity
-dnl checks the results of sdl-config to some extent
-dnl
-      rm -f conf.sdltest
-      AC_TRY_RUN([
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include "SDL.h"
+    if test $sdl_major_version -eq 1 ; then
+      sdl_ver=sdl12
+    else
+      sdl_ver=sdl2
+    fi
+  fi
 
-char*
-my_strdup (char *str)
-{
-  char *new_str;
-  
-  if (str)
-    {
-      new_str = (char *)malloc ((strlen (str) + 1) * sizeof(char));
-      strcpy (new_str, str);
-    }
+  if test x"$sdl_ver" = xsdl2 ; then
+    REQ_MAJOR=2
+    REQ_MINOR=0
+    REQ_PATCHLEVEL=0
   else
-    new_str = NULL;
-  
-  return new_str;
-}
+    REQ_MAJOR=1
+    REQ_MINOR=2
+    REQ_PATCHLEVEL=0
+  fi
+  REQ_VERSION=$REQ_MAJOR.$REQ_MINOR.$REQ_PATCHLEVEL
 
-int main (int argc, char *argv[])
-{
-  int major, minor, micro;
-  char *tmp_version;
+  AC_MSG_CHECKING([for SDL - version >= $REQ_VERSION])
 
-  /* This hangs on some systems (?)
-  system ("touch conf.sdltest");
-  */
-  { FILE *fp = fopen("conf.sdltest", "a"); if ( fp ) fclose(fp); }
 
-  /* HP/UX 9 (%@#!) writes to sscanf strings */
-  tmp_version = my_strdup("$min_sdl_version");
-  if (sscanf(tmp_version, "%d.%d.%d", &major, &minor, &micro) != 3) {
-     printf("%s, bad version string\n", "$min_sdl_version");
-     exit(1);
-   }
+  dnl Second: include "SDL.h"
 
-   if (($sdl_major_version > major) ||
-      (($sdl_major_version == major) && ($sdl_minor_version > minor)) ||
-      (($sdl_major_version == major) && ($sdl_minor_version == minor) && ($sdl_micro_version >= micro)))
+  if test x$exult_sdlok = xyes ; then
+    CPPFLAGS="$CPPFLAGS $SDL_CFLAGS"
+    AC_COMPILE_IFELSE([AC_LANG_SOURCE([[
+    #include "SDL.h"
+
+    int main(int argc, char *argv[])
     {
       return 0;
     }
-  else
-    {
-      printf("\n*** 'sdl-config --version' returned %d.%d.%d, but the minimum version\n", $sdl_major_version, $sdl_minor_version, $sdl_micro_version);
-      printf("*** of SDL required is %d.%d.%d. If sdl-config is correct, then it is\n", major, minor, micro);
-      printf("*** best to upgrade to the required version.\n");
-      printf("*** If sdl-config was wrong, set the environment variable SDL_CONFIG\n");
-      printf("*** to point to the correct copy of sdl-config, and remove the file\n");
-      printf("*** config.cache before re-running configure\n");
-      return 1;
+    ]],)],sdlh_found=yes,sdlh_found=no)
+
+    if test x$sdlh_found = xno; then
+      exult_sdlok=no
+    else
+      AC_DEFINE(HAVE_SDL_H, 1, [Define to 1 if you have the "SDL.h" header file])
+    fi
+  fi
+
+  dnl Next: version check (cross-compile-friendly idea borrowed from autoconf)
+  dnl (First check version reported by sdl-config, then confirm
+  dnl  the version in SDL.h matches it)
+
+  if test x$exult_sdlok = xyes ; then
+
+    if test ! \( \( $sdl_major_version -gt $REQ_MAJOR \) -o \( \( $sdl_major_version -eq $REQ_MAJOR \) -a \( \( $sdl_minor_version -gt $REQ_MINOR \) -o \( \( $sdl_minor_version -eq $REQ_MINOR \) -a \( $sdl_patchlevel -gt $REQ_PATCHLEVEL \) \) \) \) \); then
+      exult_sdlok="no, version < $REQ_VERSION found"
+    else
+      AC_COMPILE_IFELSE([AC_LANG_SOURCE([[
+      #include "SDL.h"
+
+      int main(int argc, char *argv[])
+      {
+        static int test_array[1-2*!(SDL_MAJOR_VERSION==$sdl_major_version&&SDL_MINOR_VERSION==$sdl_minor_version&&SDL_PATCHLEVEL==$sdl_patchlevel)];
+        test_array[0] = 0;
+        return 0;
+      }
+      ]])],,[[exult_sdlok="no, version of SDL.h doesn't match that of sdl-config"]])
+    fi
+  fi
+
+  dnl Next: try linking
+
+  if test "x$exult_sdlok" = xyes; then
+    LIBS="$LIBS $SDL_LIBS"
+
+    AC_LINK_IFELSE([AC_LANG_SOURCE([[
+    #include "SDL.h"
+
+    int main(int argc, char* argv[]) {
+      SDL_Init(0);
+      return 0;
     }
-}
+    ]])],sdllinkok=yes,sdllinkok=no)
+    if test x$sdllinkok = xno; then
+      exult_sdlok=no
+    fi
+  fi
 
-],, no_sdl=yes,[echo $ac_n "cross compiling; assumed OK... $ac_c"])
-       CFLAGS="$ac_save_CFLAGS"
-       LIBS="$ac_save_LIBS"
-     fi
-  fi
-  if test "x$no_sdl" = x ; then
-     AC_MSG_RESULT(yes)
-     ifelse([$2], , :, [$2])     
+  AC_MSG_RESULT($exult_sdlok)
+
+  LDFLAGS="$exult_backupldflags"
+  CPPFLAGS="$exult_backupcppflags"
+  LIBS="$exult_backuplibs"
+
+  if test "x$exult_sdlok" = xyes; then
+    AC_SUBST(SDL_CFLAGS)
+    AC_SUBST(SDL_LIBS)
+    ifelse([$1], , :, [$1])
   else
-     AC_MSG_RESULT(no)
-     if test "$SDL_CONFIG" = "no" ; then
-       echo "*** The sdl-config script installed by SDL could not be found"
-       echo "*** If SDL was installed in PREFIX, make sure PREFIX/bin is in"
-       echo "*** your path, or set the SDL_CONFIG environment variable to the"
-       echo "*** full path to sdl-config."
-     else
-       if test -f conf.sdltest ; then
-        :
-       else
-          echo "*** Could not run SDL test program, checking why..."
-          CFLAGS="$CFLAGS $SDL_CFLAGS"
-          LIBS="$LIBS $SDL_LIBS"
-          AC_TRY_LINK([
-#include <stdio.h>
-#include "SDL.h"
-],      [ return 0; ],
-        [ echo "*** The test program compiled, but did not run. This usually means"
-          echo "*** that the run-time linker is not finding SDL or finding the wrong"
-          echo "*** version of SDL. If it is not finding SDL, you'll need to set your"
-          echo "*** LD_LIBRARY_PATH environment variable, or edit /etc/ld.so.conf to point"
-          echo "*** to the installed location  Also, make sure you have run ldconfig if that"
-          echo "*** is required on your system"
-	  echo "***"
-          echo "*** If you have an old version installed, it is best to remove it, although"
-          echo "*** you may also be able to get things to work by modifying LD_LIBRARY_PATH"],
-        [ echo "*** The test program failed to compile or link. See the file config.log for the"
-          echo "*** exact error that occurred. This usually means SDL was incorrectly installed"
-          echo "*** or that you have moved SDL since it was installed. In the latter case, you"
-          echo "*** may want to edit the sdl-config script: $SDL_CONFIG" ])
-          CFLAGS="$ac_save_CFLAGS"
-          LIBS="$ac_save_LIBS"
-       fi
-     fi
-     SDL_CFLAGS=""
-     SDL_LIBS=""
-     ifelse([$3], , :, [$3])
+    ifelse([$2], , :, [$2])
   fi
-  AC_SUBST(SDL_CFLAGS)
-  AC_SUBST(SDL_LIBS)
-  rm -f conf.sdltest
-])
+]);
 
 dnl Configure Paths for Alsa
 dnl Some modifications by Richard Boulton <richard-alsa@tartarus.org>
@@ -303,6 +286,73 @@
 AC_SUBST(ALSA_LIBS)
 ])
 
+dnl Configure platform for SDL_cdrom compatibility layer.
+dnl MUST be called after SDL version check (defined only for SDL 2.0).
+dnl Taken off configure.in from SDL 1.2 and then modified
+AC_DEFUN([COMPAT_SDL_CDROM_GET_PLATFORM],[
+
+if test x"$sdl_ver" = xsdl12 ; then
+    compat_sdl_cdrom_arch=undefined
+elif test x"$sdl_ver" = xsdl2 ; then
+    case "$host" in
+        arm-*-elf*) # FIXME: Can we get more specific for iPodLinux?
+            compat_sdl_cdrom_arch=linux
+            ;;
+        *-*-linux*|*-*-uclinux*|*-*-gnu*|*-*-k*bsd*-gnu|*-*-bsdi*|*-*-freebsd*|*-*-dragonfly*|*-*-netbsd*|*-*-openbsd*|*-*-sysv5*|*-*-solaris*|*-*-hpux*|*-*-irix*|*-*-aix*|*-*-osf*)
+            case "$host" in
+                *-*-linux*)         compat_sdl_cdrom_arch=linux ;;
+                *-*-uclinux*)       compat_sdl_cdrom_arch=linux ;;
+                *-*-kfreebsd*-gnu)  compat_sdl_cdrom_arch=COMPAT_SDL_CDROM_PLATFORM_KFREEBSD_GNU ;;
+                *-*-knetbsd*-gnu)   compat_sdl_cdrom_arch=knetbsd-gnu ;;
+                *-*-kopenbsd*-gnu)  compat_sdl_cdrom_arch=kopenbsd-gnu ;;
+                *-*-gnu*)           compat_sdl_cdrom_arch=gnu ;; # must be last of the gnu variants
+                *-*-bsdi*)          compat_sdl_cdrom_arch=bsdi ;;
+                *-*-freebsd*)       compat_sdl_cdrom_arch=freebsd ;;
+                *-*-dragonfly*)     compat_sdl_cdrom_arch=freebsd ;;
+                *-*-netbsd*)        compat_sdl_cdrom_arch=netbsd ;;
+                *-*-openbsd*)       compat_sdl_cdrom_arch=openbsd ;;
+                *-*-sysv5*)         compat_sdl_cdrom_arch=sysv5 ;;
+                *-*-solaris*)       compat_sdl_cdrom_arch=solaris ;;
+                *-*-hpux*)          compat_sdl_cdrom_arch=hpux ;;
+                *-*-irix*)          compat_sdl_cdrom_arch=irix ;;
+                *-*-aix*)           compat_sdl_cdrom_arch=aix ;;
+                *-*-osf*)           compat_sdl_cdrom_arch=osf ;;
+            esac
+            ;;
+        *-*-qnx*)
+            compat_sdl_cdrom_arch=qnx
+            ;;
+        *-*-cygwin* | *-*-mingw32*)
+            compat_sdl_cdrom_arch=win32
+            ;;
+        *-wince*)
+            compat_sdl_cdrom_arch=win32
+            ;;
+        *-*-beos* | *-*-haiku*)
+            compat_sdl_cdrom_arch=beos
+            ;;
+        *-*-darwin* )
+            # This could be either full "Mac OS X", or plain "Darwin" which is
+            # just the OS X kernel sans upper layers like Carbon and Cocoa.
+            # Next line is broken
+            compat_sdl_cdrom_arch=macosx
+            ;;
+        *-*-mint*)
+            compat_sdl_cdrom_arch=mint
+            ;;
+        *-riscos)
+            compat_sdl_cdrom_arch=riscos
+            ;;
+        *)
+            compat_sdl_cdrom_arch=undefined
+            ;;
+    esac
+else
+    AC_MSG_ERROR([Compatible SDL version not found])
+fi
+
+]);
+
 AH_TOP([
 /*
  *  Copyright (C) 2002-2019  The DOSBox Team
Index: configure.ac
===================================================================
--- configure.ac	(revision 4281)
+++ configure.ac	(working copy)
@@ -1,5 +1,5 @@
 dnl Init.
-AC_INIT(dosbox,SVN)
+AC_INIT(dosbox,SDL2)
 AC_PREREQ(2.50)
 AC_CONFIG_SRCDIR(README)
 
@@ -27,28 +27,95 @@
 fi
 
 dnl Check for SDL
-SDL_VERSION=1.2.0
-AM_PATH_SDL($SDL_VERSION,
-            :,
-	    AC_MSG_ERROR([*** SDL version $SDL_VERSION not found!])
-)
+EXULT_CHECK_SDL(:,AC_MSG_ERROR([[*** SDL not found!]]))
 LIBS="$LIBS $SDL_LIBS"
 CPPFLAGS="$CPPFLAGS $SDL_CFLAGS"
 
-dnl Check if SDL is 1.2.x (1.3 not supported)
-AC_MSG_CHECKING([SDL version only being 1.2.X])
+dnl Check if SDL is 1.2.x, 2.0.x
+AC_MSG_CHECKING([for SDL version being 1.2.x or 2.0.x])
 AC_COMPILE_IFELSE([AC_LANG_SOURCE([
 #include "SDL.h"
 void blah(){
-#if SDL_MINOR_VERSION != 2
-#error "Only SDL 1.2 supported"
+#if !((SDL_MAJOR_VERSION == 1) && (SDL_MINOR_VERSION == 2)) && !((SDL_MAJOR_VERSION == 2) && (SDL_MINOR_VERSION == 0))
+#error "Only SDL 1.2 and 2.0 supported"
 #endif
 ;
 }
 ])],AC_MSG_RESULT([yes]),[
  AC_MSG_RESULT([no]) 
- AC_MSG_ERROR([Only libSDL 1.2.X supported])])
+ AC_MSG_ERROR([Only libSDL 1.2.x or 2.0.x supported])])
 
+dnl Check for SDL_cdrom compatibility layer platform (used with SDL 2.0 only)
+AC_MSG_CHECKING(for SDL_cdrom compatibility layer platform)
+COMPAT_SDL_CDROM_GET_PLATFORM(:)
+AH_TEMPLATE(C_COMPAT_SDL_CDROM_PLATFORM,[Platform for SDL_cdrom compatibility layer (SDL 2.0 only)])
+
+physical_cdrom_mount=1
+
+case $compat_sdl_cdrom_arch in
+    linux|solaris)
+        AC_DEFINE(C_COMPAT_SDL_CDROM_PLATFORM,[COMPAT_SDL_CDROM_PLATFORM_LINUX])
+        AC_MSG_RESULT([linux])
+        ;;
+    *freebsd*)
+        AC_DEFINE(C_COMPAT_SDL_CDROM_PLATFORM,[COMPAT_SDL_CDROM_PLATFORM_FREEBSD])
+        AC_MSG_RESULT([freebsd])
+        ;;
+    *openbsd*|*netbsd*)
+        AC_DEFINE(C_COMPAT_SDL_CDROM_PLATFORM,[COMPAT_SDL_CDROM_PLATFORM_OPENBSD])
+        AC_MSG_RESULT([openbsd])
+        ;;
+    bsdi)
+        AC_DEFINE(C_COMPAT_SDL_CDROM_PLATFORM,[COMPAT_SDL_CDROM_PLATFORM_BSDI])
+        AC_MSG_RESULT([bsdi])
+        ;;
+    aix)
+        AC_DEFINE(C_COMPAT_SDL_CDROM_PLATFORM,[COMPAT_SDL_CDROM_PLATFORM_AIX])
+        AC_MSG_RESULT([aix])
+        ;;
+    osf)
+        AC_DEFINE(C_COMPAT_SDL_CDROM_PLATFORM,[COMPAT_SDL_CDROM_PLATFORM_OSF])
+        AC_MSG_RESULT([osf])
+        ;;
+    qnx)
+        AC_DEFINE(C_COMPAT_SDL_CDROM_PLATFORM,[COMPAT_SDL_CDROM_PLATFORM_QNX])
+        AC_MSG_RESULT([qnx])
+        ;;
+    win32)
+        AC_DEFINE(C_COMPAT_SDL_CDROM_PLATFORM,[COMPAT_SDL_CDROM_PLATFORM_WIN32])
+        AC_MSG_RESULT([win32])
+        ;;
+    beos)
+        AC_DEFINE(C_COMPAT_SDL_CDROM_PLATFORM,[COMPAT_SDL_CDROM_PLATFORM_BEOS])
+        AC_MSG_RESULT([beos])
+        ;;
+    macosx)
+        AC_DEFINE(C_COMPAT_SDL_CDROM_PLATFORM,[COMPAT_SDL_CDROM_PLATFORM_MACOSX])
+        AC_MSG_RESULT([macosx])
+        ;;
+    mint)
+        AC_DEFINE(C_COMPAT_SDL_CDROM_PLATFORM,[COMPAT_SDL_CDROM_PLATFORM_MINT])
+        AC_MSG_RESULT([mint])
+        ;;
+    *)
+        physical_cdrom_mount=0
+        AC_MSG_RESULT([disabled])
+esac
+
+if test x"$sdl_ver" = xsdl12 ; then
+    physical_cdrom_mount=1
+fi
+
+AC_MSG_CHECKING(for physical cdrom mounting support)
+AH_TEMPLATE(C_PHYSICAL_CDROM_MOUNT,[Physical CD-ROM mounting support])
+if test x"$physical_cdrom_mount" = x1 ; then
+    AC_MSG_RESULT(yes)
+    AC_DEFINE(C_PHYSICAL_CDROM_MOUNT,[1])
+else
+    AC_MSG_RESULT(no)
+fi
+
+
 dnl Checks for header files.
 
 dnl Checks for typedefs, structures, and compiler characteristics.
@@ -459,23 +526,29 @@
 AH_TEMPLATE(C_IPX,[Define to 1 to enable IPX over Internet networking, requires SDL_net])
 AC_CHECK_HEADER(SDL_net.h,have_sdl_net_h=yes,)
 
+if test x"$sdl_ver" = xsdl2 ; then 
+  LIBSDL_HEADER="SDL2"
+else
+  LIBSDL_HEADER="SDL"
+fi
+
 if test x$host = xi386-pc-os2-emx ; then
-  AC_MSG_CHECKING(for SDLNet_Init in SDL_net);
+  AC_MSG_CHECKING(for SDLNet_Init in ${LIBSDL_HEADER}_net);
   LIBS_BACKUP=$LIBS;
-  LIBS="$LIBS -lSDL_Net";
+  LIBS="$LIBS -l${LIBSDL_HEADER}_Net";
   AC_LINK_IFELSE([AC_LANG_PROGRAM([[#include <SDL_Net.h>]],[[
 	SDLNet_Init ();
   ]])], [AC_MSG_RESULT(yes); have_sdl_net_lib=yes], AC_MSG_RESULT(no))
   LIBS=$LIBS_BACKUP
 else
-AC_CHECK_LIB(SDL_net, SDLNet_Init, have_sdl_net_lib=yes, , )
+AC_CHECK_LIB(${LIBSDL_HEADER}_net, SDLNet_Init, have_sdl_net_lib=yes, , )
 fi
 if test x$have_sdl_net_lib = xyes -a x$have_sdl_net_h = xyes ; then
-   LIBS="$LIBS -lSDL_net"
+   LIBS="$LIBS -l${LIBSDL_HEADER}_net"
    AC_DEFINE(C_MODEM,1)
    AC_DEFINE(C_IPX,1)
 else 
-   AC_MSG_WARN([Can't find SDL_net, internal modem and ipx disabled])
+   AC_MSG_WARN([Can't find ${LIBSDL_HEADER}_net, internal modem and ipx disabled])
 fi
 
 AH_TEMPLATE(C_X11_XKB,[define to 1 if you have XKBlib.h and X11 lib])
@@ -542,12 +615,12 @@
 fi
 
 AH_TEMPLATE(C_SDL_SOUND,[Define to 1 to enable SDL_sound support])
-AC_CHECK_HEADER(SDL_sound.h,have_SDL_sound_h=yes,)
+AC_CHECK_HEADER(SDL2/SDL_sound.h,have_SDL_sound_h=yes,)
 AC_CHECK_LIB(SDL_sound, Sound_Init, have_SDL_sound_init=yes,,)
 AC_CHECK_LIB(SDL_sound, Sound_Seek, have_SDL_sound_seek=yes,,)
 if test x$have_SDL_sound_h = xyes -a x$have_SDL_sound_init = xyes ; then
   if test x$have_SDL_sound_seek = xyes ; then
-    LIBS="-lSDL_sound $LIBS"
+    LIBS="-lSDL2_sound $LIBS"
     AC_DEFINE(C_SDL_SOUND,1)
    else 
      AC_MSG_WARN([Can't find SoundSeek in libSDL_Sound, libSDL_sound support disabled])
@@ -591,6 +664,7 @@
        dnl to do more to distinguish them.
        dnl For now I am lazy and do not add proper detection code.
        AC_DEFINE(MACOSX, 1, [Compiling on Mac OS X])
+       LIBS="$LIBS -framework CoreFoundation -framework Cocoa"
        AC_DEFINE(C_DIRECTSERIAL, 1, [ Define to 1 if you want serial passthrough support (Win32, Posix and OS/2).])
        ;;
     *-*-linux*)
@@ -649,6 +723,9 @@
 src/shell/Makefile
 src/platform/Makefile
 src/platform/visualc/Makefile
+src/sdl_cdrom/Makefile
+src/sdl_cdrom/macos/Makefile
+src/sdl_cdrom/macosx/Makefile
 visualc_net/Makefile
 include/Makefile
 docs/Makefile
Index: src/Makefile.am
===================================================================
--- src/Makefile.am	(revision 4281)
+++ src/Makefile.am	(working copy)
@@ -1,6 +1,6 @@
 AM_CPPFLAGS = -I$(top_srcdir)/include
 
-SUBDIRS = cpu debug dos fpu gui hardware libs ints misc shell platform 
+SUBDIRS = cpu debug dos fpu gui hardware libs ints misc shell platform sdl_cdrom 
 
 bin_PROGRAMS = dosbox
 
@@ -14,7 +14,8 @@
 dosbox_SOURCES = dosbox.cpp $(ico_stuff)
 dosbox_LDADD = cpu/libcpu.a debug/libdebug.a dos/libdos.a fpu/libfpu.a  hardware/libhardware.a gui/libgui.a \
                ints/libints.a misc/libmisc.a shell/libshell.a hardware/mame/libmame.a \
-               hardware/serialport/libserial.a libs/gui_tk/libgui_tk.a
+               hardware/serialport/libserial.a libs/gui_tk/libgui_tk.a \
+               sdl_cdrom/libcsdlcdrom.a sdl_cdrom/macos/libcsdlcdrommacos.a sdl_cdrom/macosx/libcsdlcdrommacosx.a
 
 EXTRA_DIST = winres.rc dosbox.ico
 
Index: src/dos/cdrom.cpp
===================================================================
--- src/dos/cdrom.cpp	(revision 4281)
+++ src/dos/cdrom.cpp	(working copy)
@@ -21,6 +21,7 @@
 // SDL CDROM 
 // ******************************************************
 
+
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <unistd.h>
@@ -30,6 +31,8 @@
 #include "support.h"
 #include "cdrom.h"
 
+#if C_PHYSICAL_CDROM_MOUNT
+
 CDROM_Interface_SDL::CDROM_Interface_SDL(void) {
 	driveID		= 0;
 	oldLeadOut	= 0;
@@ -143,6 +146,8 @@
 	return success;
 }
 
+#endif /* C_PHYSICAL_CDROM_MOUNT */
+
 int CDROM_GetMountType(char* path, int forceCD) {
 // 0 - physical CDROM
 // 1 - Iso file
@@ -157,6 +162,7 @@
 	upcase(buffer);
 #endif
 
+#if C_PHYSICAL_CDROM_MOUNT
 	int num = SDL_CDNumDrives();
 	// If cd drive is forced then check if its in range and return 0
 	if ((forceCD>=0) && (forceCD<num)) {
@@ -169,6 +175,7 @@
 		cdName = SDL_CDName(i);
 		if (strcmp(buffer,cdName)==0) return 0;
 	};
+#endif
 	
 	// Detect ISO
 	struct stat file_stat;
@@ -214,5 +221,3 @@
 	trayOpen     = false;
 	return true;
 }
-
-
Index: src/dos/cdrom.h
===================================================================
--- src/dos/cdrom.h	(revision 4281)
+++ src/dos/cdrom.h	(working copy)
@@ -32,6 +32,11 @@
 #include "mem.h"
 #include "mixer.h"
 #include "SDL.h"
+#if SDL_VERSION_ATLEAST(2,0,0)
+/* Do include this, even if C_PHYSICAL_CDROM_MOUNT is *not* defined,
+due to MSF_TO_FRAMES and FRAMES_TO_MSF (and indirectly also CD_FPS). */
+#include "../sdl_cdrom/compat_SDL_cdrom.h"
+#endif
 #include "SDL_thread.h"
 
 #if defined(C_SDL_SOUND)
@@ -41,7 +46,9 @@
 #define RAW_SECTOR_SIZE		2352
 #define COOKED_SECTOR_SIZE	2048
 
+#if C_PHYSICAL_CDROM_MOUNT
 enum { CDROM_USE_SDL, CDROM_USE_ASPI, CDROM_USE_IOCTL_DIO, CDROM_USE_IOCTL_DX, CDROM_USE_IOCTL_MCI };
+#endif
 
 typedef struct SMSF {
 	unsigned char min;
@@ -84,6 +91,7 @@
 	virtual void	InitNewMedia		(void) {};
 };	
 
+#if C_PHYSICAL_CDROM_MOUNT
 class CDROM_Interface_SDL : public CDROM_Interface
 {
 public:
@@ -112,6 +120,7 @@
 	int		driveID;
 	Uint32	oldLeadOut;
 };
+#endif /* C_PHYSICAL_CDROM_MOUNT */
 
 class CDROM_Interface_Fake : public CDROM_Interface
 {
@@ -237,6 +246,8 @@
 	Bit8u	subUnit;
 };
 
+#if C_PHYSICAL_CDROM_MOUNT
+
 #if defined (WIN32)	/* Win 32 */
 
 #define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers
@@ -394,4 +405,6 @@
 
 #endif /* LINUX */
 
+#endif /* C_PHYSICAL_CDROM_MOUNT */
+
 #endif /* __CDROM_INTERFACE__ */
Index: src/dos/cdrom_aspi_win32.cpp
===================================================================
--- src/dos/cdrom_aspi_win32.cpp	(revision 4281)
+++ src/dos/cdrom_aspi_win32.cpp	(working copy)
@@ -17,11 +17,14 @@
  */
 
 
+#include "dosbox.h"
+
+#if C_PHYSICAL_CDROM_MOUNT
+
 #if defined (WIN32)
 
 #include <ctype.h>
 
-#include "dosbox.h"
 #include "cdrom.h"
 #include "support.h"
 
@@ -766,3 +769,4 @@
 };
 
 #endif
+#endif /* C_PHYSICAL_CDROM_MOUNT */
Index: src/dos/cdrom_ioctl_linux.cpp
===================================================================
--- src/dos/cdrom_ioctl_linux.cpp	(revision 4281)
+++ src/dos/cdrom_ioctl_linux.cpp	(working copy)
@@ -17,8 +17,11 @@
  */
  
 
+#include "cdrom.h"
+
+#if C_PHYSICAL_CDROM_MOUNT
+
 #include <string.h>
-#include "cdrom.h"
 #include "support.h"
 
 #if defined (LINUX)
@@ -95,3 +98,4 @@
 }
 
 #endif
+#endif /* C_PHYSICAL_CDROM_MOUNT */
Index: src/dos/cdrom_ioctl_os2.cpp
===================================================================
--- src/dos/cdrom_ioctl_os2.cpp	(revision 4281)
+++ src/dos/cdrom_ioctl_os2.cpp	(working copy)
@@ -17,8 +17,11 @@
  */
 
 
+#include "dosbox.h"
+
+#if C_PHYSICAL_CDROM_MOUNT
+
 #include <string.h>
-#include "dosbox.h"
 #include "cdrom.h"
 
 #if defined (OS2)
@@ -150,3 +153,4 @@
 }
 
 #endif
+#endif /* C_PHYSICAL_CDROM_MOUNT */
Index: src/dos/cdrom_ioctl_win32.cpp
===================================================================
--- src/dos/cdrom_ioctl_win32.cpp	(revision 4281)
+++ src/dos/cdrom_ioctl_win32.cpp	(working copy)
@@ -17,6 +17,10 @@
  */
 
 
+#include "cdrom.h"
+
+#if C_PHYSICAL_CDROM_MOUNT
+
 #if defined (WIN32)
 
 // *****************************************************************
@@ -35,8 +39,6 @@
 
 #include <mmsystem.h>
 
-#include "cdrom.h"
-
 // for a more sophisticated implementation of the mci cdda functionality
 // see the SDL sources, which the mci_ functions are based on
 
@@ -621,3 +623,4 @@
 }
 
 #endif
+#endif /* C_PHYSICAL_CDROM_MOUNT */
Index: src/dos/dos_mscdex.cpp
===================================================================
--- src/dos/dos_mscdex.cpp	(revision 4281)
+++ src/dos/dos_mscdex.cpp	(working copy)
@@ -48,7 +48,9 @@
 #define	REQUEST_STATUS_ERROR	0x8000
 
 // Use cdrom Interface
+#if C_PHYSICAL_CDROM_MOUNT
 int useCdromInterface	= CDROM_USE_SDL;
+#endif
 int forceCD				= -1;
 
 static Bitu MSCDEX_Strategy_Handler(void); 
@@ -253,6 +255,7 @@
 	int result = 0;
 	// Get Mounttype and init needed cdrom interface
 	switch (CDROM_GetMountType(physicalPath,forceCD)) {
+#if C_PHYSICAL_CDROM_MOUNT
 	case 0x00: {	
 		LOG(LOG_MISC,LOG_NORMAL)("MSCDEX: Mounting physical cdrom: %s"	,physicalPath);
 #if defined (WIN32)
@@ -295,6 +298,7 @@
 		LOG(LOG_MISC,LOG_NORMAL)("MSCDEX: SDL Interface.");
 #endif
 		} break;
+#endif /* C_PHYSICAL_CDROM_MOUNT */
 	case 0x01:	// iso cdrom interface	
 		LOG(LOG_MISC,LOG_NORMAL)("MSCDEX: Mounting iso file as cdrom: %s", physicalPath);
 		cdrom[numDrives] = new CDROM_Interface_Image((Bit8u)numDrives);
@@ -1334,10 +1338,12 @@
 	return true;
 }
 
+#if C_PHYSICAL_CDROM_MOUNT
 void MSCDEX_SetCDInterface(int intNr, int numCD) {
 	useCdromInterface = intNr;
 	forceCD	= numCD;
 }
+#endif
 
 void MSCDEX_ShutDown(Section* /*sec*/) {
 	delete mscdex;
Index: src/dos/dos_programs.cpp
===================================================================
--- src/dos/dos_programs.cpp	(revision 4281)
+++ src/dos/dos_programs.cpp	(working copy)
@@ -56,7 +56,12 @@
 Bitu DEBUG_EnableDebugger(void);
 #endif
 
+#if C_PHYSICAL_CDROM_MOUNT
+#define PROGRAM_INTRO_CDROM_SUFFIX "PROGRAM_INTRO_CDROM_PHYS"
 void MSCDEX_SetCDInterface(int intNr, int forceCD);
+#else
+#define PROGRAM_INTRO_CDROM_SUFFIX "PROGRAM_INTRO_CDROM_NOPHYS"
+#endif
 static Bitu ZDRIVE_NUM = 25;
 
 static const char* UnmountHelper(char umount) {
@@ -205,11 +210,15 @@
 
 		/* Show list of cdroms */
 		if (cmd->FindExist("-cd",false)) {
+#if C_PHYSICAL_CDROM_MOUNT
 			int num = SDL_CDNumDrives();
    			WriteOut(MSG_Get("PROGRAM_MOUNT_CDROMS_FOUND"),num);
 			for (int i=0; i<num; i++) {
 				WriteOut("%2d. %s\n",i,SDL_CDName(i));
 			};
+#else
+			WriteOut(MSG_Get("PROGRAM_MOUNT_PHYS_CDROMS_NOT_SUPPORTED"));
+#endif
 			return;
 		}
 
@@ -353,9 +362,10 @@
 			if (temp_line[temp_line.size()-1]!=CROSS_FILESPLIT) temp_line+=CROSS_FILESPLIT;
 			Bit8u bit8size=(Bit8u) sizes[1];
 			if (type=="cdrom") {
+				int error = 0;
+#if C_PHYSICAL_CDROM_MOUNT
 				int num = -1;
 				cmd->FindInt("-usecd",num,true);
-				int error = 0;
 				if (cmd->FindExist("-aspi",false)) {
 					MSCDEX_SetCDInterface(CDROM_USE_ASPI, num);
 				} else if (cmd->FindExist("-ioctl_dio",false)) {
@@ -384,6 +394,20 @@
 					MSCDEX_SetCDInterface(CDROM_USE_IOCTL_DIO, num);
 #endif
 				}
+#else /* C_PHYSICAL_CDROM_MOUNT */
+				if (cmd->FindExist("-usecd",false)
+				    || cmd->FindExist("-aspi",false)
+				    || cmd->FindExist("-ioctl_dio",false)
+				    || cmd->FindExist("-ioctl_dx",false)
+#if defined (WIN32)
+				    || cmd->FindExist("-ioctl_mci",false)
+#endif
+				    || cmd->FindExist("-noioctl",false)
+				) {
+					WriteOut(MSG_Get("PROGRAM_MOUNT_PHYS_CDROMS_NOT_SUPPORTED"));
+					/* Just ignore, mount anyway */
+				}
+#endif /* C_PHYSICAL_CDROM_MOUNT */
 				newdrive  = new cdromDrive(drive,temp_line.c_str(),sizes[0],bit8size,sizes[2],0,mediaid,error);
 				// Check Mscdex, if it worked out...
 				switch (error) {
@@ -1190,7 +1214,8 @@
 		/* Only run if called from the first shell (Xcom TFTD runs any intro file in the path) */
 		if(DOS_PSP(dos.psp()).GetParent() != DOS_PSP(DOS_PSP(dos.psp()).GetParent()).GetParent()) return;
 		if(cmd->FindExist("cdrom",false)) {
-			WriteOut(MSG_Get("PROGRAM_INTRO_CDROM"));
+			WriteOut(MSG_Get("PROGRAM_INTRO_CDROM_PREFIX"));
+			WriteOut(MSG_Get(PROGRAM_INTRO_CDROM_SUFFIX));
 			return;
 		}
 		if(cmd->FindExist("mount",false)) {
@@ -1208,7 +1233,8 @@
 		DOS_ReadFile (STDIN,&c,&n);
 		DisplayMount();
 		DOS_ReadFile (STDIN,&c,&n);
-		WriteOut(MSG_Get("PROGRAM_INTRO_CDROM"));
+		WriteOut(MSG_Get("PROGRAM_INTRO_CDROM_PREFIX"));
+		WriteOut(MSG_Get(PROGRAM_INTRO_CDROM_SUFFIX));
 		DOS_ReadFile (STDIN,&c,&n);
 		WriteOut(MSG_Get("PROGRAM_INTRO_SPECIAL"));
 	}
@@ -1470,8 +1496,9 @@
 				WriteOut(MSG_Get("PROGRAM_IMGMOUNT_ALREADY_MOUNTED"));
 				return;
 			}
-
+#if C_PHYSICAL_CDROM_MOUNT
 			MSCDEX_SetCDInterface(CDROM_USE_SDL, -1);
+#endif
 			// create new drives for all images
 			std::vector<DOS_Drive*> isoDisks;
 			std::vector<std::string>::size_type i;
@@ -1627,7 +1654,8 @@
 void DOS_SetupPrograms(void) {
 	/*Add Messages */
 
-	MSG_Add("PROGRAM_MOUNT_CDROMS_FOUND","CDROMs found: %d\n");
+	MSG_Add("PROGRAM_MOUNT_CDROMS_FOUND","CDROMs found: %d\n"); // C_PHYSICAL_CDROM_MOUNT
+	MSG_Add("PROGRAM_MOUNT_PHYS_CDROMS_NOT_SUPPORTED","Physical CDROMs aren't fully supported. IMGMOUNT may be more useful.\n"); // !C_PHYSICAL_CDROM_MOUNT
 	MSG_Add("PROGRAM_MOUNT_STATUS_FORMAT","%-5s  %-58s %-12s\n");
 	MSG_Add("PROGRAM_MOUNT_STATUS_2","Drive %c is mounted as %s\n");
 	MSG_Add("PROGRAM_MOUNT_STATUS_1","The currently mounted drives are:\n");
@@ -1716,7 +1744,7 @@
 		"enter a directory (recognised by the \033[33;1m[]\033[0m in a directory listing).\n"
 		"You can run programs/files which end with \033[31m.exe .bat\033[0m and \033[31m.com\033[0m.\n"
 		);
-	MSG_Add("PROGRAM_INTRO_CDROM",
+	MSG_Add("PROGRAM_INTRO_CDROM_PREFIX",
 		"\033[2J\033[32;1mHow to mount a Real/Virtual CD-ROM Drive in DOSBox:\033[0m\n"
 		"DOSBox provides CD-ROM emulation on several levels.\n"
 		"\n"
@@ -1727,6 +1755,8 @@
 		"If it doesn't work you might have to tell DOSBox the label of the CD-ROM:\n"
 		"\033[34;1mmount d C:\\example -t cdrom -label CDLABEL\033[0m\n"
 		"\n"
+		);
+	MSG_Add("PROGRAM_INTRO_CDROM_PHYS", // C_PHYSICAL_CDROM_MOUNT
 		"The \033[33mnext\033[0m level adds some low-level support.\n"
 		"Therefore only works on CD-ROM drives:\n"
 		"\033[34;1mmount d \033[0;31mD:\\\033[34;1m -t cdrom -usecd \033[33m0\033[0m\n"
@@ -1741,6 +1771,14 @@
 		"Replace the \033[33;1m0\033[0m in \033[34;1m-usecd \033[33m0\033[0m with the number reported for your CD-ROM if you type:\n"
 		"\033[34;1mmount -cd\033[0m\n"
 		);
+	MSG_Add("PROGRAM_INTRO_CDROM_NOPHYS", // !C_PHYSICAL_CDROM_MOUNT
+		"The \033[33mhigher\033[0m level adds CD-ROM image mounting support.\n"
+		"Therefore only works on supported CD-ROM images:\n"
+		"\033[34;1mimgmount d \033[0;31mD:\\example.img\033[34;1m -t cdrom\033[0m\n"
+		"\n"
+		"Replace \033[0;31mD:\\\033[0m with the location of your CD-ROM.\n"
+		"Replace \033[0;31mD:\\example.img\033[0m with the location of your CD-ROM image.\n"
+		);
 	MSG_Add("PROGRAM_INTRO_SPECIAL",
 		"\033[2J\033[32;1mSpecial keys:\033[0m\n"
 		"These are the default keybindings.\n"
Index: src/dos/drive_local.cpp
===================================================================
--- src/dos/drive_local.cpp	(revision 4281)
+++ src/dos/drive_local.cpp	(working copy)
@@ -273,7 +273,12 @@
 
 	find_size=(Bit32u) stat_block.st_size;
 	struct tm *time;
+#ifdef __ANDROID__ // temp_stat.st_mtime is of type unsigned long, not time_t
+	time_t rawtime=stat_block.st_mtime;
+	if((time=localtime(&rawtime))!=0){
+#else
 	if((time=localtime(&stat_block.st_mtime))!=0){
+#endif
 		find_date=DOS_PackDate((Bit16u)(time->tm_year+1900),(Bit16u)(time->tm_mon+1),(Bit16u)time->tm_mday);
 		find_time=DOS_PackTime((Bit16u)time->tm_hour,(Bit16u)time->tm_min,(Bit16u)time->tm_sec);
 	} else {
@@ -391,7 +396,12 @@
 	if(stat(newname,&temp_stat)!=0) return false;
 	/* Convert the stat to a FileStat */
 	struct tm *time;
+#ifdef __ANDROID__ // temp_stat.st_mtime is of type unsigned long, not time_t
+	time_t rawtime=temp_stat.st_mtime;
+	if((time=localtime(&rawtime))!=0) {
+#else
 	if((time=localtime(&temp_stat.st_mtime))!=0) {
+#endif
 		stat_block->time=DOS_PackTime((Bit16u)time->tm_hour,(Bit16u)time->tm_min,(Bit16u)time->tm_sec);
 		stat_block->date=DOS_PackDate((Bit16u)(time->tm_year+1900),(Bit16u)(time->tm_mon+1),(Bit16u)time->tm_mday);
 	} else {
@@ -531,7 +541,12 @@
 	struct stat temp_stat;
 	fstat(fileno(fhandle),&temp_stat);
 	struct tm * ltime;
+#ifdef __ANDROID__ // temp_stat.st_mtime is of type unsigned long, not time_t
+	time_t rawtime=temp_stat.st_mtime;
+	if((ltime=localtime(&rawtime))!=0) {
+#else
 	if((ltime=localtime(&temp_stat.st_mtime))!=0) {
+#endif
 		time=DOS_PackTime((Bit16u)ltime->tm_hour,(Bit16u)ltime->tm_min,(Bit16u)ltime->tm_sec);
 		date=DOS_PackDate((Bit16u)(ltime->tm_year+1900),(Bit16u)(ltime->tm_mon+1),(Bit16u)ltime->tm_mday);
 	} else {
Index: src/gui/sdl_mapper.cpp
===================================================================
--- src/gui/sdl_mapper.cpp	(revision 4281)
+++ src/gui/sdl_mapper.cpp	(working copy)
@@ -44,7 +44,8 @@
 	CLR_WHITE=2,
 	CLR_RED=3,
 	CLR_BLUE=4,
-	CLR_GREEN=5
+	CLR_GREEN=5,
+	CLR_LAST
 };
 
 enum BB_Types {
@@ -67,7 +68,8 @@
 
 #define MAXSTICKS 8
 #define MAXACTIVE 16
-#define MAXBUTTON 32
+// Use 36 for Android (KEYCODE_BUTTON_1..16 are mapped to SDL buttons 20..35)
+#define MAXBUTTON 36
 #define MAXBUTTON_CAP 16
 
 class CEvent;
@@ -299,6 +301,8 @@
 };
 
 
+#if !SDL_VERSION_ATLEAST(2,0,0)
+
 #define MAX_SDLKEYS 323
 
 static bool usescancodes;
@@ -469,23 +473,41 @@
 	}
 }
 
+#endif // SDL 1.2
 
+
 class CKeyBind;
 class CKeyBindGroup;
 
 class CKeyBind : public CBind {
 public:
+#if SDL_VERSION_ATLEAST(2,0,0)
+	CKeyBind(CBindList * _list,SDL_Scancode _key) : CBind(_list) {
+#else
 	CKeyBind(CBindList * _list,SDLKey _key) : CBind(_list) {
+#endif
 		key = _key;
 	}
 	void BindName(char * buf) {
+#if SDL_VERSION_ATLEAST(2,0,0)
+		sprintf(buf,"Key %s",SDL_GetScancodeName(key));
+#else
 		sprintf(buf,"Key %s",SDL_GetKeyName(MapSDLCode((Bitu)key)));
+#endif
 	}
 	void ConfigName(char * buf) {
+#if SDL_VERSION_ATLEAST(2,0,0)
+		sprintf(buf,"key %d",key);
+#else
 		sprintf(buf,"key %d",MapSDLCode((Bitu)key));
+#endif
 	}
 public:
+#if SDL_VERSION_ATLEAST(2,0,0)
+	SDL_Scancode key;
+#else
 	SDLKey key;
+#endif
 };
 
 class CKeyBindGroup : public  CBindGroup {
@@ -501,28 +523,44 @@
 		if (strncasecmp(buf,configname,strlen(configname))) return 0;
 		StripWord(buf);char * num=StripWord(buf);
 		Bitu code=ConvDecWord(num);
+#if SDL_VERSION_ATLEAST(2,0,0)
+		CBind * bind=CreateKeyBind((SDL_Scancode)code);
+#else
 		if (usescancodes) {
 			if (code<MAX_SDLKEYS) code=scancode_map[code];
 			else code=0;
 		}
 		CBind * bind=CreateKeyBind((SDLKey)code);
+#endif
 		return bind;
 	}
 	CBind * CreateEventBind(SDL_Event * event) {
 		if (event->type!=SDL_KEYDOWN) return 0;
+#if SDL_VERSION_ATLEAST(2,0,0)
+		return CreateKeyBind(event->key.keysym.scancode);
+#else
 		return CreateKeyBind((SDLKey)GetKeyCode(event->key.keysym));
+#endif
 	};
 	bool CheckEvent(SDL_Event * event) {
 		if (event->type!=SDL_KEYDOWN && event->type!=SDL_KEYUP) return false;
+#if SDL_VERSION_ATLEAST(2,0,0)
+		Bitu key = event->key.keysym.scancode;
+#else	// SDL 1.2
 		Bitu key=GetKeyCode(event->key.keysym);
 //		LOG_MSG("key type %i is %x [%x %x]",event->type,key,event->key.keysym.sym,event->key.keysym.scancode);
 		assert(Bitu(event->key.keysym.sym)<keys);
+#endif	// SDL 2.0/1.2
 		if (event->type==SDL_KEYDOWN) ActivateBindList(&lists[key],0x7fff,true);
 		else DeactivateBindList(&lists[key],true);
 		return 0;
 	}
+#if SDL_VERSION_ATLEAST(2,0,0)
+	CBind * CreateKeyBind(SDL_Scancode _key) {
+#else
 	CBind * CreateKeyBind(SDLKey _key) {
 		if (!usescancodes) assert((Bitu)_key<keys);
+#endif
 		return new CKeyBind(&lists[(Bitu)_key],_key);
 	}
 private:
@@ -675,7 +713,11 @@
 		if (axes_cap>axes) axes_cap=axes;
 		hats_cap=emulated_hats;
 		if (hats_cap>hats) hats_cap=hats;
+#if SDL_VERSION_ATLEAST(2,0,0)
+		LOG_MSG("Using joystick %s with %d axes, %d buttons and %d hat(s)",SDL_JoystickNameForIndex(stick),axes,buttons,hats);
+#else
 		LOG_MSG("Using joystick %s with %d axes, %d buttons and %d hat(s)",SDL_JoystickName(stick),axes,buttons,hats);
+#endif
 	}
 	~CStickBindGroup() {
 		SDL_JoystickClose(sdl_joystick);
@@ -881,7 +923,11 @@
 		return configname;
 	}
 	const char * BindStart(void) {
+#if SDL_VERSION_ATLEAST(2,0,0)
+		if (sdl_joystick!=NULL) return SDL_JoystickNameForIndex(stick);
+#else
 		if (sdl_joystick!=NULL) return SDL_JoystickName(stick);
+#endif
 		else return "[missing joystick]";
 	}
 
@@ -1240,6 +1286,11 @@
 };
 
 static struct CMapper {
+#if SDL_VERSION_ATLEAST(2,0,0)
+	SDL_Window * window;
+	SDL_Rect draw_rect;
+	SDL_Surface * draw_surface_nonpaletted; // Needed for SDL_BlitScaled
+#endif
 	SDL_Surface * surface;
 	SDL_Surface * draw_surface;
 	bool exit;
@@ -1277,7 +1328,7 @@
 }
 
 static void DrawText(Bitu x,Bitu y,const char * text,Bit8u color) {
-	Bit8u * draw=((Bit8u *)mapper.surface->pixels)+(y*mapper.surface->pitch)+x;
+	Bit8u * draw=((Bit8u *)mapper.draw_surface->pixels)+(y*mapper.draw_surface->w)+x;
 	while (*text) {
 		Bit8u * font=&int10_font_14[(*text)*14];
 		Bitu i,j;Bit8u * draw_line=draw;
@@ -1288,7 +1339,7 @@
 				else *(draw_line+j)=CLR_BLACK;
 				map<<=1;
 			}
-			draw_line+=mapper.surface->pitch;
+			draw_line+=mapper.draw_surface->w;
 		}
 		text++;draw+=8;
 	}
@@ -1305,7 +1356,7 @@
 	}
 	virtual void Draw(void) {
 		if (!enabled) return;
-		Bit8u * point=((Bit8u *)mapper.surface->pixels)+(y*mapper.surface->pitch)+x;
+		Bit8u * point=((Bit8u *)mapper.draw_surface->pixels)+(y*mapper.draw_surface->w)+x;
 		for (Bitu lines=0;lines<dy;lines++)  {
 			if (lines==0 || lines==(dy-1)) {
 				for (Bitu cols=0;cols<dx;cols++) *(point+cols)=color;
@@ -1312,7 +1363,7 @@
 			} else {
 				*point=color;*(point+dx-1)=color;
 			}
-			point+=mapper.surface->pitch;
+			point+=mapper.draw_surface->w;
 		}
 	}
 	virtual bool OnTop(Bitu _x,Bitu _y) {
@@ -1343,13 +1394,21 @@
 	const char * text;
 };
 
+class CClickableTextButton : public CTextButton {
+public:
+	CClickableTextButton(Bitu _x,Bitu _y,Bitu _dx,Bitu _dy,const char * _text) : CTextButton(_x,_y,_dx,_dy,_text) {}
+	void BindColor(void) {
+		this->SetColor(CLR_WHITE);
+	}
+};
+
 class CEventButton;
 static CEventButton * last_clicked = NULL;
 
-class CEventButton : public CTextButton {
+class CEventButton : public CClickableTextButton {
 public:
 	CEventButton(Bitu _x,Bitu _y,Bitu _dx,Bitu _dy,const char * _text,CEvent * _event) 
-	: CTextButton(_x,_y,_dx,_dy,_text) 	{ 
+	: CClickableTextButton(_x,_y,_dx,_dy,_text) 	{ 
 		event=_event;	
 	}
 	void BindColor(void) {
@@ -1391,10 +1450,10 @@
 static void change_action_text(const char* text,Bit8u col);
 
 static void MAPPER_SaveBinds(void);
-class CBindButton : public CTextButton {
+class CBindButton : public CClickableTextButton {
 public:	
 	CBindButton(Bitu _x,Bitu _y,Bitu _dx,Bitu _dy,const char * _text,BB_Types _type) 
-	: CTextButton(_x,_y,_dx,_dy,_text) 	{ 
+	: CClickableTextButton(_x,_y,_dx,_dy,_text) 	{ 
 		type=_type;
 	}
 	void Click(void) {
@@ -1433,10 +1492,10 @@
 	BB_Types type;
 };
 
-class CCheckButton : public CTextButton {
+class CCheckButton : public CClickableTextButton {
 public:	
 	CCheckButton(Bitu _x,Bitu _y,Bitu _dx,Bitu _dy,const char * _text,BC_Types _type) 
-	: CTextButton(_x,_y,_dx,_dy,_text) 	{ 
+	: CClickableTextButton(_x,_y,_dx,_dy,_text) 	{ 
 		type=_type;
 	}
 	void Draw(void) {
@@ -1457,13 +1516,13 @@
 			break;
 		}
 		if (checked) {
-			Bit8u * point=((Bit8u *)mapper.surface->pixels)+((y+2)*mapper.surface->pitch)+x+dx-dy+2;
+			Bit8u * point=((Bit8u *)mapper.draw_surface->pixels)+((y+2)*mapper.draw_surface->w)+x+dx-dy+2;
 			for (Bitu lines=0;lines<(dy-4);lines++)  {
 				memset(point,color,dy-4);
-				point+=mapper.surface->pitch;
+				point+=mapper.draw_surface->w;
 			}
 		}
-		CTextButton::Draw();
+		CClickableTextButton::Draw();
 	}
 	void Click(void) {
 		switch (type) {
@@ -1589,25 +1648,53 @@
 		case MK_f1:case MK_f2:case MK_f3:case MK_f4:
 		case MK_f5:case MK_f6:case MK_f7:case MK_f8:
 		case MK_f9:case MK_f10:case MK_f11:case MK_f12:	
+#if SDL_VERSION_ATLEAST(2,0,0)
+			key=SDL_SCANCODE_F1+(defkey-MK_f1);
+#else
 			key=SDLK_F1+(defkey-MK_f1);
+#endif
 			break;
 		case MK_return:
+#if SDL_VERSION_ATLEAST(2,0,0)
+			key=SDL_SCANCODE_RETURN;
+#else
 			key=SDLK_RETURN;
+#endif
 			break;
 		case MK_kpminus:
+#if SDL_VERSION_ATLEAST(2,0,0)
+			key=SDL_SCANCODE_KP_MINUS;
+#else
 			key=SDLK_KP_MINUS;
+#endif
 			break;
 		case MK_scrolllock:
+#if SDL_VERSION_ATLEAST(2,0,0)
+			key=SDL_SCANCODE_SCROLLLOCK;
+#else
 			key=SDLK_SCROLLOCK;
+#endif
 			break;
 		case MK_pause:
+#if SDL_VERSION_ATLEAST(2,0,0)
+			key=SDL_SCANCODE_PAUSE;
+#else
 			key=SDLK_PAUSE;
+#endif
 			break;
 		case MK_printscreen:
+#if SDL_VERSION_ATLEAST(2,0,0)
+			key=SDL_SCANCODE_PRINTSCREEN;
+#else
 			key=SDLK_PRINT;
+#endif
 			break;
 		case MK_home: 
+#if SDL_VERSION_ATLEAST(2,0,0)
+			key=SDL_SCANCODE_HOME; 
+#else
 			key=SDLK_HOME; 
+#endif
 			break;
 		}
 		sprintf(buf,"%s \"key %d%s%s%s\"",
@@ -1689,14 +1776,27 @@
 	}
 }
 
+#if SDL_VERSION_ATLEAST(2,0,0)
+extern SDL_Window * GFX_SetSDLSurfaceWindow(Bit16u width, Bit16u height);
+extern SDL_Rect GFX_GetSDLSurfaceSubwindowDims(Bit16u width, Bit16u height);
+extern void GFX_UpdateDisplayDimensions(int width, int height);
+#endif
+
 static void DrawButtons(void) {
-	SDL_FillRect(mapper.surface,0,CLR_BLACK);
-	SDL_LockSurface(mapper.surface);
+	SDL_FillRect(mapper.draw_surface,0,CLR_BLACK);
 	for (CButton_it but_it = buttons.begin();but_it!=buttons.end();but_it++) {
 		(*but_it)->Draw();
 	}
-	SDL_UnlockSurface(mapper.surface);
+#if SDL_VERSION_ATLEAST(2,0,0)
+	// We can't just use SDL_BlitScaled (say for Android) in one step
+	SDL_BlitSurface(mapper.draw_surface, NULL, mapper.draw_surface_nonpaletted, NULL);
+	SDL_BlitScaled(mapper.draw_surface_nonpaletted, NULL, mapper.surface, &mapper.draw_rect);
+	//SDL_BlitSurface(mapper.draw_surface, NULL, mapper.surface, NULL);
+	SDL_UpdateWindowSurface(mapper.window);
+#else
+	SDL_BlitSurface(mapper.draw_surface, NULL, mapper.surface, NULL);
 	SDL_Flip(mapper.surface);
+#endif
 }
 
 static CKeyEvent * AddKeyButtonEvent(Bitu x,Bitu y,Bitu dx,Bitu dy,char const * const title,char const * const entry,KBD_KEYS key) {
@@ -2003,7 +2103,7 @@
 	bind_but.bind_title->Change("Bind Title");
 }
 
-static SDL_Color map_pal[6]={
+static SDL_Color map_pal[CLR_LAST]={
 	{0x00,0x00,0x00,0x00},			//0=black
 	{0x7f,0x7f,0x7f,0x00},			//1=grey
 	{0xff,0xff,0xff,0x00},			//2=white
@@ -2042,6 +2142,49 @@
 	const char * eventend;
 	Bitu key;
 } DefaultKeys[]={
+
+#if SDL_VERSION_ATLEAST(2,0,0)
+
+	{"f1",SDL_SCANCODE_F1},		{"f2",SDL_SCANCODE_F2},		{"f3",SDL_SCANCODE_F3},		{"f4",SDL_SCANCODE_F4},
+	{"f5",SDL_SCANCODE_F5},		{"f6",SDL_SCANCODE_F6},		{"f7",SDL_SCANCODE_F7},		{"f8",SDL_SCANCODE_F8},
+	{"f9",SDL_SCANCODE_F9},		{"f10",SDL_SCANCODE_F10},	{"f11",SDL_SCANCODE_F11},	{"f12",SDL_SCANCODE_F12},
+
+	{"1",SDL_SCANCODE_1},		{"2",SDL_SCANCODE_2},		{"3",SDL_SCANCODE_3},		{"4",SDL_SCANCODE_4},
+	{"5",SDL_SCANCODE_5},		{"6",SDL_SCANCODE_6},		{"7",SDL_SCANCODE_7},		{"8",SDL_SCANCODE_8},
+	{"9",SDL_SCANCODE_9},		{"0",SDL_SCANCODE_0},
+
+	{"a",SDL_SCANCODE_A},		{"b",SDL_SCANCODE_B},		{"c",SDL_SCANCODE_C},		{"d",SDL_SCANCODE_D},
+	{"e",SDL_SCANCODE_E},		{"f",SDL_SCANCODE_F},		{"g",SDL_SCANCODE_G},		{"h",SDL_SCANCODE_H},
+	{"i",SDL_SCANCODE_I},		{"j",SDL_SCANCODE_J},		{"k",SDL_SCANCODE_K},		{"l",SDL_SCANCODE_L},
+	{"m",SDL_SCANCODE_M},		{"n",SDL_SCANCODE_N},		{"o",SDL_SCANCODE_O},		{"p",SDL_SCANCODE_P},
+	{"q",SDL_SCANCODE_Q},		{"r",SDL_SCANCODE_R},		{"s",SDL_SCANCODE_S},		{"t",SDL_SCANCODE_T},
+	{"u",SDL_SCANCODE_U},		{"v",SDL_SCANCODE_V},		{"w",SDL_SCANCODE_W},		{"x",SDL_SCANCODE_X},
+	{"y",SDL_SCANCODE_Y},		{"z",SDL_SCANCODE_Z},		{"space",SDL_SCANCODE_SPACE},
+	{"esc",SDL_SCANCODE_ESCAPE},	{"equals",SDL_SCANCODE_EQUALS},		{"grave",SDL_SCANCODE_GRAVE},
+	{"tab",SDL_SCANCODE_TAB},		{"enter",SDL_SCANCODE_RETURN},		{"bspace",SDL_SCANCODE_BACKSPACE},
+	{"lbracket",SDL_SCANCODE_LEFTBRACKET},						{"rbracket",SDL_SCANCODE_RIGHTBRACKET},
+	{"minus",SDL_SCANCODE_MINUS},	{"capslock",SDL_SCANCODE_CAPSLOCK},	{"semicolon",SDL_SCANCODE_SEMICOLON},
+	{"quote", SDL_SCANCODE_APOSTROPHE},	{"backslash",SDL_SCANCODE_BACKSLASH},	{"lshift",SDL_SCANCODE_LSHIFT},
+	{"rshift",SDL_SCANCODE_RSHIFT},	{"lalt",SDL_SCANCODE_LALT},			{"ralt",SDL_SCANCODE_RALT},
+	{"lctrl",SDL_SCANCODE_LCTRL},	{"rctrl",SDL_SCANCODE_RCTRL},		{"comma",SDL_SCANCODE_COMMA},
+	{"period",SDL_SCANCODE_PERIOD},	{"slash",SDL_SCANCODE_SLASH},		{"printscreen",SDL_SCANCODE_PRINTSCREEN},
+	{"scrolllock",SDL_SCANCODE_SCROLLLOCK},	{"pause",SDL_SCANCODE_PAUSE},		{"pagedown",SDL_SCANCODE_PAGEDOWN},
+	{"pageup",SDL_SCANCODE_PAGEUP},	{"insert",SDL_SCANCODE_INSERT},		{"home",SDL_SCANCODE_HOME},
+	{"delete",SDL_SCANCODE_DELETE},	{"end",SDL_SCANCODE_END},			{"up",SDL_SCANCODE_UP},
+	{"left",SDL_SCANCODE_LEFT},		{"down",SDL_SCANCODE_DOWN},			{"right",SDL_SCANCODE_RIGHT},
+	{"kp_0",SDL_SCANCODE_KP_0},	{"kp_1",SDL_SCANCODE_KP_1},	{"kp_2",SDL_SCANCODE_KP_2},	{"kp_3",SDL_SCANCODE_KP_3},
+	{"kp_4",SDL_SCANCODE_KP_4},	{"kp_5",SDL_SCANCODE_KP_5},	{"kp_6",SDL_SCANCODE_KP_6},	{"kp_7",SDL_SCANCODE_KP_7},
+	{"kp_8",SDL_SCANCODE_KP_8},	{"kp_9",SDL_SCANCODE_KP_9},	{"numlock",SDL_SCANCODE_NUMLOCKCLEAR},
+	{"kp_divide",SDL_SCANCODE_KP_DIVIDE},	{"kp_multiply",SDL_SCANCODE_KP_MULTIPLY},
+	{"kp_minus",SDL_SCANCODE_KP_MINUS},		{"kp_plus",SDL_SCANCODE_KP_PLUS},
+	{"kp_period",SDL_SCANCODE_KP_PERIOD},	{"kp_enter",SDL_SCANCODE_KP_ENTER},
+
+	/* Is that the extra backslash key ("less than" key) */
+	/* on some keyboards with the 102-keys layout??      */
+	{"lessthan",SDL_SCANCODE_NONUSBACKSLASH},
+
+#else	// !SDL_VERSION_ATLEAST(2,0,0)
+
 	{"f1",SDLK_F1},		{"f2",SDLK_F2},		{"f3",SDLK_F3},		{"f4",SDLK_F4},
 	{"f5",SDLK_F5},		{"f6",SDLK_F6},		{"f7",SDLK_F7},		{"f8",SDLK_F8},
 	{"f9",SDLK_F9},		{"f10",SDLK_F10},	{"f11",SDLK_F11},	{"f12",SDLK_F12},
@@ -2083,6 +2226,8 @@
 	{"lessthan",SDLK_LESS},
 #endif
 
+#endif	// !SDL_VERSION_ATLEAST(2,0,0)
+
 	{0,0}
 };
 
@@ -2094,10 +2239,17 @@
 		CreateStringBind(buffer);
 		i++;
 	}
+#if SDL_VERSION_ATLEAST(2,0,0)
+	sprintf(buffer,"mod_1 \"key %d\"",SDL_SCANCODE_RCTRL);CreateStringBind(buffer);
+	sprintf(buffer,"mod_1 \"key %d\"",SDL_SCANCODE_LCTRL);CreateStringBind(buffer);
+	sprintf(buffer,"mod_2 \"key %d\"",SDL_SCANCODE_RALT);CreateStringBind(buffer);
+	sprintf(buffer,"mod_2 \"key %d\"",SDL_SCANCODE_LALT);CreateStringBind(buffer);
+#else
 	sprintf(buffer,"mod_1 \"key %d\"",SDLK_RCTRL);CreateStringBind(buffer);
 	sprintf(buffer,"mod_1 \"key %d\"",SDLK_LCTRL);CreateStringBind(buffer);
 	sprintf(buffer,"mod_2 \"key %d\"",SDLK_RALT);CreateStringBind(buffer);
 	sprintf(buffer,"mod_2 \"key %d\"",SDLK_LALT);CreateStringBind(buffer);
+#endif
 	for (CHandlerEventVector_it hit=handlergroup.begin();hit!=handlergroup.end();hit++) {
 		(*hit)->MakeDefaultBind(buffer);
 		CreateStringBind(buffer);
@@ -2190,17 +2342,92 @@
 
 void BIND_MappingEvents(void) {
 	SDL_Event event;
+	static bool isButtonPressed = false;
+	static CButton *lastHoveredButton = NULL;
 	while (SDL_PollEvent(&event)) {
 		switch (event.type) {
+		case SDL_MOUSEBUTTONDOWN:
+			isButtonPressed = true;
+			/* Further check where are we pointing at right now */
+		case SDL_MOUSEMOTION:
+			if (!isButtonPressed)
+				break;
+#if SDL_VERSION_ATLEAST(2,0,0)
+			/* Normalize position in case a scaled sub-window is used (say on Android) */
+			event.button.x=(event.button.x-mapper.draw_rect.x)*mapper.draw_surface->w/mapper.draw_rect.w;
+			if ((event.button.x<0) || (event.button.x>=mapper.draw_surface->w))
+				break;
+			event.button.y=(event.button.y-mapper.draw_rect.y)*mapper.draw_surface->h/mapper.draw_rect.h;
+			if ((event.button.y<0) || (event.button.y>=mapper.draw_surface->h))
+				break;
+#endif
+			/* Maybe we have been pointing at a specific button for a little while  */
+			if (lastHoveredButton) {
+				/* Check if there's any change */
+				if (lastHoveredButton->OnTop(event.button.x,event.button.y))
+					break;
+				/* Not pointing at given button anymore */
+				if (lastHoveredButton == last_clicked)
+					lastHoveredButton->Click();
+				else
+					lastHoveredButton->BindColor();
+				mapper.redraw=true;
+				lastHoveredButton=NULL;
+			}
+			/* Check which button are we currently pointing at */
+			for (CButton_it but_it = buttons.begin();but_it!=buttons.end();but_it++) {
+				if (dynamic_cast<CClickableTextButton *>(*but_it) && (*but_it)->OnTop(event.button.x,event.button.y)) {
+					(*but_it)->SetColor(CLR_RED);
+					mapper.redraw=true;
+					lastHoveredButton=*but_it;
+					break;
+				}
+			}
+			break;
 		case SDL_MOUSEBUTTONUP:
+			isButtonPressed = false;
+			if (lastHoveredButton) {
+				/* For most buttons the actual new color is going to be green; But not for a few others. */
+				lastHoveredButton->BindColor();
+				mapper.redraw=true;
+				lastHoveredButton = NULL;
+			}
+#if SDL_VERSION_ATLEAST(2,0,0)
+			/* Normalize position in case a scaled sub-window is used (say on Android) */
+			event.button.x=(event.button.x-mapper.draw_rect.x)*mapper.draw_surface->w/mapper.draw_rect.w;
+			if ((event.button.x<0) || (event.button.x>=mapper.draw_surface->w))
+				break;
+			event.button.y=(event.button.y-mapper.draw_rect.y)*mapper.draw_surface->h/mapper.draw_rect.h;
+			if ((event.button.y<0) || (event.button.y>=mapper.draw_surface->h))
+				break;
+#endif
 			/* Check the press */
 			for (CButton_it but_it = buttons.begin();but_it!=buttons.end();but_it++) {
-				if ((*but_it)->OnTop(event.button.x,event.button.y)) {
+				if (dynamic_cast<CClickableTextButton *>(*but_it) && (*but_it)->OnTop(event.button.x,event.button.y)) {
 					(*but_it)->Click();
+					break;
 				}
-			}	
+			}
 			break;
+#if SDL_VERSION_ATLEAST(2,0,0)
+		case SDL_WINDOWEVENT:
+			/* The resize event MAY arrive e.g. when the mapper is
+			 * toggled, at least on X11. Furthermore, the restore
+			 * event should be handled on Android.
+			 */
+			if ((event.window.event == SDL_WINDOWEVENT_RESIZED)
+			    || (event.window.event == SDL_WINDOWEVENT_RESTORED)) {
+				mapper.surface = SDL_GetWindowSurface(mapper.window);
+				if (mapper.surface == NULL) E_Exit("Couldn't refresh mapper window surface after resize or restoration: %s",SDL_GetError());
+				GFX_UpdateDisplayDimensions(event.window.data1, event.window.data2);
+				mapper.draw_rect=GFX_GetSDLSurfaceSubwindowDims(640,480);
+				DrawButtons();
+			}
+			break;
+#endif
 		case SDL_QUIT:
+			isButtonPressed = false;
+			lastHoveredButton = NULL;
 			mapper.exit=true;
 			break;
 		default:
@@ -2275,7 +2502,11 @@
 
 static void CreateBindGroups(void) {
 	bindgroups.clear();
+#if SDL_VERSION_ATLEAST(2,0,0)
+	new CKeyBindGroup(SDL_NUM_SCANCODES);
+#else
 	new CKeyBindGroup(SDLK_LAST);
+#endif
 	if (joytype != JOY_NONE) {
 #if defined (REDUCE_JOYSTICK_POLLING)
 		// direct access to the SDL joystick, thus removed from the event handling
@@ -2358,11 +2589,29 @@
 
 	/* Be sure that there is no update in progress */
 	GFX_EndUpdate( 0 );
-	mapper.surface=SDL_SetVideoMode_Wrap(640,480,8,0);
+#if SDL_VERSION_ATLEAST(2,0,0)
+	mapper.window=GFX_SetSDLSurfaceWindow(640,480);
+	if (mapper.window == NULL) E_Exit("Could not initialize video mode for mapper: %s",SDL_GetError());
+	mapper.surface=SDL_GetWindowSurface(mapper.window);
+	if (mapper.surface == NULL) E_Exit("Could not retrieve window surface for mapper: %s",SDL_GetError());
+#else
+	mapper.surface=SDL_SetVideoMode_Wrap(640,480,0,0);
 	if (mapper.surface == NULL) E_Exit("Could not initialize video mode for mapper: %s",SDL_GetError());
+#endif
 
 	/* Set some palette entries */
-	SDL_SetPalette(mapper.surface, SDL_LOGPAL|SDL_PHYSPAL, map_pal, 0, 6);
+	mapper.draw_surface=SDL_CreateRGBSurface(0,640,480,8,0,0,0,0);
+#if SDL_VERSION_ATLEAST(2,0,0)
+	// Needed for SDL_BlitScaled
+	mapper.draw_surface_nonpaletted=SDL_CreateRGBSurface(0,640,480,32,0x0000ff00,0x00ff0000,0xff000000,0);
+	mapper.draw_rect=GFX_GetSDLSurfaceSubwindowDims(640,480);
+	// Sorry, but SDL_SetSurfacePalette requires a full palette.
+	SDL_Palette *sdl2_map_pal_ptr = SDL_AllocPalette(256);
+	SDL_SetPaletteColors(sdl2_map_pal_ptr, map_pal, 0, CLR_LAST);
+	SDL_SetSurfacePalette(mapper.draw_surface, sdl2_map_pal_ptr);
+#else	// !SDL_VERSION_ATLEAST(2,0,0)
+	SDL_SetPalette(mapper.draw_surface, SDL_LOGPAL|SDL_PHYSPAL, map_pal, 0, CLR_LAST);
+#endif
 	if (last_clicked) {
 		last_clicked->BindColor();
 		last_clicked=NULL;
@@ -2378,10 +2627,23 @@
 		if (mapper.redraw) {
 			mapper.redraw=false;		
 			DrawButtons();
+		} else {
+#if SDL_VERSION_ATLEAST(2,0,0)
+			SDL_UpdateWindowSurface(mapper.window);
+#else
+			SDL_Flip(mapper.surface);
+#endif
 		}
 		BIND_MappingEvents();
 		SDL_Delay(1);
 	}
+	/* ONE SHOULD NOT FORGET TO DO THIS!
+	Unless a memory leak is desired... */
+	SDL_FreeSurface(mapper.draw_surface);
+#if SDL_VERSION_ATLEAST(2,0,0)
+	SDL_FreeSurface(mapper.draw_surface_nonpaletted);
+	SDL_FreePalette(sdl2_map_pal_ptr);
+#endif
 #if defined (REDUCE_JOYSTICK_POLLING)
 	SDL_JoystickEventState(SDL_DISABLE);
 #endif
@@ -2430,6 +2692,8 @@
 	mapper.sticks.num_groups=0;
 	memset(&virtual_joysticks,0,sizeof(virtual_joysticks));
 
+#if !SDL_VERSION_ATLEAST(2,0,0)
+
 	usescancodes = false;
 
 	if (section->Get_bool("usescancodes")) {
@@ -2554,6 +2818,8 @@
 		}
 	}
 
+#endif	// !SDL_VERSION_ATLEAST(2,0,0)
+
 	Prop_path* pp = section->Get_path("mapperfile");
 	mapper.filename = pp->realpath;
 	MAPPER_AddHandler(&MAPPER_Run,MK_f1,MMOD1,"mapper","Mapper");
Index: src/gui/sdlmain.cpp
===================================================================
--- src/gui/sdlmain.cpp	(revision 4281)
+++ src/gui/sdlmain.cpp	(working copy)
@@ -31,9 +31,15 @@
 #include <signal.h>
 #include <process.h>
 #endif
+#ifdef __ANDROID__
+#include <android/log.h>
+#endif
 
 #include "cross.h"
 #include "SDL.h"
+#if SDL_VERSION_ATLEAST(2,0,0) && C_PHYSICAL_CDROM_MOUNT
+#include "../sdl_cdrom/compat_SDL_cdrom.h"
+#endif
 
 #include "dosbox.h"
 #include "video.h"
@@ -50,11 +56,19 @@
 #include "cross.h"
 #include "control.h"
 
+#if SDL_VERSION_ATLEAST(2,0,0)
+#define MAPPERFILE "mapper-sdl2-" VERSION ".map"
+#else
 #define MAPPERFILE "mapper-" VERSION ".map"
+#endif
 //#define DISABLE_JOYSTICK
 
 #if C_OPENGL
+#ifdef __ANDROID__
+#include "SDL_opengles.h"
+#else
 #include "SDL_opengl.h"
+#endif
 
 #ifndef APIENTRY
 #define APIENTRY
@@ -81,6 +95,7 @@
 typedef GLboolean (APIENTRYP PFNGLUNMAPBUFFERARBPROC) (GLenum target);
 #endif
 
+#ifndef __ANDROID__
 PFNGLGENBUFFERSARBPROC glGenBuffersARB = NULL;
 PFNGLBINDBUFFERARBPROC glBindBufferARB = NULL;
 PFNGLDELETEBUFFERSARBPROC glDeleteBuffersARB = NULL;
@@ -87,6 +102,7 @@
 PFNGLBUFFERDATAARBPROC glBufferDataARB = NULL;
 PFNGLMAPBUFFERARBPROC glMapBufferARB = NULL;
 PFNGLUNMAPBUFFERARBPROC glUnmapBufferARB = NULL;
+#endif
 
 #endif //C_OPENGL
 
@@ -129,8 +145,12 @@
 
 enum SCREEN_TYPES	{
 	SCREEN_SURFACE,
+#if SDL_VERSION_ATLEAST(2,0,0)
+	SCREEN_TEXTURE,
+#else
 	SCREEN_SURFACE_DDRAW,
 	SCREEN_OVERLAY,
+#endif
 	SCREEN_OPENGL
 };
 
@@ -148,10 +168,13 @@
 	bool inited;
 	bool active;							//If this isn't set don't draw
 	bool updating;
+#if SDL_VERSION_ATLEAST(2,0,0)
+	bool update_display_contents;
+	bool resizing_window;
+#endif
 	struct {
 		Bit32u width;
 		Bit32u height;
-		Bit32u bpp;
 		Bitu flags;
 		double scalex,scaley;
 		GFX_CallBack_t callback;
@@ -161,25 +184,39 @@
 		struct {
 			Bit16u width, height;
 			bool fixed;
+#if SDL_VERSION_ATLEAST(2,0,0)
+			bool display_res;
+#endif
 		} full;
 		struct {
 			Bit16u width, height;
 		} window;
 		Bit8u bpp;
+#if SDL_VERSION_ATLEAST(2,0,0)
+		Bit32u sdl2pixelFormat;
+#endif
 		bool fullscreen;
 		bool lazy_fullscreen;
 		bool lazy_fullscreen_req;
-		bool doublebuf;
+		bool vsync;
 		SCREEN_TYPES type;
 		SCREEN_TYPES want_type;
 	} desktop;
 #if C_OPENGL
 	struct {
+#if SDL_VERSION_ATLEAST(2,0,0)
+		SDL_GLContext context;
+#endif
 		Bitu pitch;
 		void * framebuf;
 		GLuint buffer;
 		GLuint texture;
+#ifdef __ANDROID__ // OpenGL ES
+		GLfloat vertCoords[8];
+		GLfloat texCoords[8];
+#else // OpenGL (not ES)
 		GLuint displaylist;
+#endif
 		GLint max_texsize;
 		bool bilinear;
 		bool packed_pixel;
@@ -186,7 +223,8 @@
 		bool paletted_texture;
 		bool pixel_buffer_object;
 	} opengl;
-#endif
+#endif	// C_OPENGL
+#if !SDL_VERSION_ATLEAST(2,0,0)
 	struct {
 		SDL_Surface * surface;
 #if C_DDRAW
@@ -193,6 +231,7 @@
 		RECT rect;
 #endif
 	} blit;
+#endif // Not SDL v2.0
 	struct {
 		PRIORITY_LEVELS focus;
 		PRIORITY_LEVELS nofocus;
@@ -199,7 +238,18 @@
 	} priority;
 	SDL_Rect clip;
 	SDL_Surface * surface;
+#if SDL_VERSION_ATLEAST(2,0,0)
+	SDL_Window * window;
+	SDL_Renderer * renderer;
+	const char * rendererDriver;
+	int displayNumber;
+	struct {
+		SDL_Texture * texture;
+		SDL_PixelFormat * pixelFormat;
+	} texture;
+#else
 	SDL_Overlay * overlay;
+#endif
 	SDL_cond *cond;
 	struct {
 		bool autolock;
@@ -208,6 +258,13 @@
 		bool locked;
 		int xsensitivity;
 		int ysensitivity;
+#ifdef __ANDROID__
+		SDL_FingerID leftMouseFingerID, rightMouseFingerID,
+		             middleMouseFingerID, mouseMotionFingerID,
+		             escKeyFingerID;
+		bool isLeftMouseFingerUsed, isRightMouseFingerUsed,
+		     isMiddleMouseFingerUsed, isEscKeyFingerUsed;
+#endif
 	} mouse;
 	SDL_Rect updateRects[1024];
 	Bitu num_joysticks;
@@ -217,12 +274,14 @@
 	Bit32u focus_ticks;
 #endif
 	// state of alt-keys for certain special handlings
-	Bit8u laltstate;
-	Bit8u raltstate;
+	SDL_EventType laltstate;
+	SDL_EventType raltstate;
 };
 
 static SDL_Block sdl;
 
+#if !SDL_VERSION_ATLEAST(2,0,0)
+
 #define SETMODE_SAVES 1  //Don't set Video Mode if nothing changes.
 #define SETMODE_SAVES_CLEAR 1 //Clear the screen, when the Video Mode is reused
 SDL_Surface* SDL_SetVideoMode_Wrap(int width,int height,int bpp,Bit32u flags){
@@ -280,6 +339,42 @@
 	return s;
 }
 
+#endif // !SDL_VERSION_ATLEAST(2,0,0)
+
+#if SDL_VERSION_ATLEAST(2,0,0)
+static int SDL_Init_Wrapper(void)
+{
+	// Don't init timers, GetTicks seems to work fine and they can use a fair amount of power (Macs again) 
+	// Please report problems with audio and other things.
+	int result = ( SDL_Init( SDL_INIT_AUDIO|SDL_INIT_VIDEO /* | SDL_INIT_TIMER */
+		|SDL_INIT_NOPARACHUTE
+	));
+#if C_PHYSICAL_CDROM_MOUNT
+	return (result < 0) ? result : Compat_SDL_CDROMInit();
+#else
+	return result;
+#endif
+}
+#else
+static int SDL_Init_Wrapper(void)
+{
+	// Don't init timers, GetTicks seems to work fine and they can use a fair amount of power (Macs again) 
+	// Please report problems with audio and other things.
+	return (SDL_Init( SDL_INIT_AUDIO|SDL_INIT_VIDEO /* | SDL_INIT_TIMER */
+		|SDL_INIT_CDROM
+		|SDL_INIT_NOPARACHUTE
+	));
+}
+#endif
+
+static void SDL_Quit_Wrapper(void)
+{
+#if SDL_VERSION_ATLEAST(2,0,0) && C_PHYSICAL_CDROM_MOUNT
+	Compat_SDL_CDROMQuit();
+#endif
+	SDL_Quit();
+}
+
 extern const char* RunningProgram;
 extern bool CPU_CycleAutoAdjust;
 //Globals for keyboard initialisation
@@ -299,7 +394,11 @@
 	}
 
 	if (paused) strcat(title," PAUSED");
+#if SDL_VERSION_ATLEAST(2,0,0)
+	SDL_SetWindowTitle(sdl.window,title);
+#else
 	SDL_WM_SetCaption(title,VERSION);
+#endif
 }
 
 static unsigned char logo[32*32*4]= {
@@ -315,8 +414,13 @@
 #else
 	SDL_Surface* logos= SDL_CreateRGBSurfaceFrom((void*)logo,32,32,32,128,0x000000ff,0x0000ff00,0x00ff0000,0);
 #endif
+
+#if SDL_VERSION_ATLEAST(2,0,0)
+	SDL_SetWindowIcon(sdl.window, logos);
+#else
 	SDL_WM_SetIcon(logos,NULL);
-#endif
+#endif // SDL_VERSION_ATLEAST(2,0,0)
+#endif // !defined(MACOSX)
 }
 
 
@@ -337,12 +441,21 @@
 	while (SDL_PollEvent(&event)) {
 		// flush event queue.
 	}
-
+	/* NOTE: This is one of the few places where we use SDL key codes
+	with SDL 2.0, rather than scan codes. Is that the correct behavior? */
 	while (paused) {
 		SDL_WaitEvent(&event);    // since we're not polling, cpu usage drops to 0.
 		switch (event.type) {
 
 			case SDL_QUIT: KillSwitch(true); break;
+#if SDL_VERSION_ATLEAST(2,0,0)
+			case SDL_WINDOWEVENT:
+				if (event.window.event == SDL_WINDOWEVENT_RESTORED) {
+					// We may need to re-create a texture and more
+					GFX_ResetScreen();
+				}
+				break;
+#endif
 			case SDL_KEYDOWN:   // Must use Pause/Break Key to resume.
 			case SDL_KEYUP:
 			if(event.key.keysym.sym == SDLK_PAUSE) {
@@ -352,7 +465,15 @@
 				break;
 			}
 #if defined (MACOSX)
-			if (event.key.keysym.sym == SDLK_q && (event.key.keysym.mod == KMOD_RMETA || event.key.keysym.mod == KMOD_LMETA) ) {
+			if (event.key.keysym.sym == SDLK_q &&
+#if SDL_VERSION_ATLEAST(2,0,0)
+			    (event.key.keysym.mod == KMOD_RGUI ||
+			     event.key.keysym.mod == KMOD_LGUI)
+#else
+			    (event.key.keysym.mod == KMOD_RMETA ||
+			     event.key.keysym.mod == KMOD_LMETA)
+#endif
+			   ) {
 				/* On macs, all aps exit when pressing cmd-q */
 				KillSwitch(true);
 				break;
@@ -362,19 +483,26 @@
 	}
 }
 
+#if !SDL_VERSION_ATLEAST(2,0,0)
 #if defined (WIN32)
 bool GFX_SDLUsingWinDIB(void) {
 	return sdl.using_windib;
 }
 #endif
+#endif
 
 /* Reset the screen with current values in the sdl structure */
 Bitu GFX_GetBestMode(Bitu flags) {
-	Bitu testbpp,gotbpp;
+#if !SDL_VERSION_ATLEAST(2,0,0)
+ 	Bitu testbpp,gotbpp;
+#endif
 	switch (sdl.desktop.want_type) {
 	case SCREEN_SURFACE:
 check_surface:
 		flags &= ~GFX_LOVE_8;		//Disable love for 8bpp modes
+#if !SDL_VERSION_ATLEAST(2,0,0)
+		/* TODO: Maybe remove support for output=surface with SDL 2.0? */
+
 		/* Check if we can satisfy the depth it loves */
 		if (flags & GFX_LOVE_8) testbpp=8;
 		else if (flags & GFX_LOVE_15) testbpp=15;
@@ -387,7 +515,11 @@
 		if (sdl.desktop.fullscreen) gotbpp=SDL_VideoModeOK(640,480,testbpp,SDL_FULLSCREEN|SDL_HWSURFACE|SDL_HWPALETTE);
 		else gotbpp=sdl.desktop.bpp;
 		/* If we can't get our favorite mode check for another working one */
-		switch (gotbpp) {
+		switch (gotbpp)
+#else	// SDL_VERSION_ATLEAST(2,0,0)
+		switch (sdl.desktop.bpp)
+#endif
+		{
 		case 8:
 			if (flags & GFX_CAN_8) flags&=~(GFX_CAN_15|GFX_CAN_16|GFX_CAN_32);
 			break;
@@ -404,6 +536,7 @@
 		}
 		flags |= GFX_CAN_RANDOM;
 		break;
+#if !SDL_VERSION_ATLEAST(2,0,0)
 #if C_DDRAW
 	case SCREEN_SURFACE_DDRAW:
 		if (!(flags&(GFX_CAN_15|GFX_CAN_16|GFX_CAN_32))) goto check_surface;
@@ -421,8 +554,14 @@
 		flags|=GFX_SCALING;
 		flags&=~(GFX_CAN_8|GFX_CAN_15|GFX_CAN_16);
 		break;
+#endif	// !SDL_VERSION_ATLEAST(2,0,0)
+#if C_OPENGL || SDL_VERSION_ATLEAST(2,0,0)
 #if C_OPENGL
 	case SCREEN_OPENGL:
+#endif
+#if SDL_VERSION_ATLEAST(2,0,0)
+	case SCREEN_TEXTURE:
+#endif
 		//We only accept 32bit output from the scalers here
 		if (!(flags&GFX_CAN_32)) goto check_surface;
 		flags|=GFX_SCALING;
@@ -462,8 +601,145 @@
     return log;
 }
 
+#if SDL_VERSION_ATLEAST(2,0,0)
 
-static SDL_Surface * GFX_SetupSurfaceScaled(Bit32u sdl_flags, Bit32u bpp) {
+static SDL_Window * GFX_SetSDLWindowMode(Bit16u width, Bit16u height, bool fullscreen, SCREEN_TYPES screenType) {
+	static SCREEN_TYPES lastType = SCREEN_SURFACE; 
+	if (sdl.renderer) {
+		SDL_DestroyRenderer(sdl.renderer);
+		sdl.renderer=0;
+	}
+	if (sdl.texture.pixelFormat) {
+		SDL_FreeFormat(sdl.texture.pixelFormat);
+		sdl.texture.pixelFormat = 0;
+	}
+	if (sdl.texture.texture) {
+		SDL_DestroyTexture(sdl.texture.texture);
+		sdl.texture.texture=0;
+	}
+#if C_OPENGL
+	if (sdl.opengl.context) {
+		SDL_GL_DeleteContext(sdl.opengl.context);
+		sdl.opengl.context=0;
+	}
+#endif
+	int currWidth, currHeight;
+	if (sdl.window && sdl.resizing_window) {
+		SDL_GetWindowSize(sdl.window, &currWidth, &currHeight);
+		sdl.update_display_contents = ((width <= currWidth) && (height <= currHeight));
+
+		return sdl.window;
+	}
+	/* If we change screen type, recreate the window. Furthermore, if
+	 * it is our very first time then we simply create a new window.
+	 */
+	if (!sdl.window || (lastType != screenType)) {
+		lastType = screenType;
+		if (sdl.window) {
+			SDL_DestroyWindow(sdl.window);
+		}
+		/* Don't create a fullscreen immediately. Reasons:
+		 * 1. This theoretically allows us to set window resolution and
+		 * then let SDL2 remember it for later (even if not actually done).
+		 * 2. It's a bit less glitchy to set a custom display mode for a
+		 * full screen, albeit it's still not perfect (at least on X11).
+		 */
+		sdl.window = SDL_CreateWindow("",
+		                 SDL_WINDOWPOS_UNDEFINED_DISPLAY(sdl.displayNumber),
+		                 SDL_WINDOWPOS_UNDEFINED_DISPLAY(sdl.displayNumber),
+		                 width, height,
+		                 ((screenType == SCREEN_OPENGL) ? SDL_WINDOW_OPENGL : 0) | SDL_WINDOW_SHOWN
+		);
+		if (!sdl.window) {
+			return sdl.window;
+		}
+		GFX_SetTitle(-1,-1,false); //refresh title.
+		if (!fullscreen) {
+			goto finish;
+		}
+	}
+	/* Fullscreen mode switching has its limits, and is also problematic on
+	 * some window managers. For now, the following may work up to some
+	 * level. On X11, SDL_VIDEO_X11_LEGACY_FULLSCREEN=1 can also help,
+	 * although it has its own issues.
+	 * Suggestion: Use the desktop res if possible, with output=surface
+	 * if one is not interested in scaling.
+	 * On Android, desktop res is the only way.
+	 */
+	if (fullscreen) {
+		SDL_DisplayMode displayMode;
+		SDL_GetWindowDisplayMode(sdl.window, &displayMode);
+		displayMode.w = width;
+		displayMode.h = height;
+		SDL_SetWindowDisplayMode(sdl.window, &displayMode);
+
+		SDL_SetWindowFullscreen(sdl.window, sdl.desktop.full.display_res ? SDL_WINDOW_FULLSCREEN_DESKTOP : SDL_WINDOW_FULLSCREEN);
+	} else {
+		SDL_SetWindowFullscreen(sdl.window, 0);
+
+		SDL_SetWindowSize(sdl.window, width, height);
+	}
+	// Maybe some requested fullscreen resolution is unsupported?
+finish:
+	SDL_GetWindowSize(sdl.window, &currWidth, &currHeight);
+	sdl.update_display_contents = ((width <= currWidth) && (height <= currHeight));
+	return sdl.window;
+}
+
+// Used for the mapper UI and more: Creates a fullscreen window with desktop res
+// on Android, and a non-fullscreen window with the input dimensions otherwise.
+SDL_Window * GFX_SetSDLSurfaceWindow(Bit16u width, Bit16u height) {
+#ifdef __ANDROID__
+	return GFX_SetSDLWindowMode(sdl.desktop.full.width, sdl.desktop.full.height, true, SCREEN_SURFACE);
+#else
+	return GFX_SetSDLWindowMode(width, height, false, SCREEN_SURFACE);
+#endif
+}
+
+// Returns the rectangle in the current window to be used for scaling a
+// sub-window with the given dimensions, like the mapper UI.
+SDL_Rect GFX_GetSDLSurfaceSubwindowDims(Bit16u width, Bit16u height) {
+	SDL_Rect rect;
+#ifdef __ANDROID__
+	// Wider than width:height
+	if (height*sdl.desktop.full.width > sdl.desktop.full.height*width) {
+		rect.w=sdl.desktop.full.height*width/height;
+		rect.h=sdl.desktop.full.height;
+		rect.x=(sdl.desktop.full.width-rect.w)/2;
+		rect.y=0;
+	} else { // NOT wider than width:height
+		rect.w=sdl.desktop.full.width;
+		rect.h=sdl.desktop.full.width*height/width;
+		rect.x=0;
+		rect.y=(sdl.desktop.full.height-rect.h)/2;
+	}
+#else
+	rect.x=rect.y=0;
+	rect.w=width;
+	rect.h=height;
+#endif
+	return rect;
+}
+
+// Currently used for an initial test here
+static SDL_Window * GFX_SetSDLOpenGLWindow(Bit16u width, Bit16u height) {
+#ifdef __ANDROID__
+	return GFX_SetSDLWindowMode(sdl.desktop.full.width, sdl.desktop.full.height, true, SCREEN_OPENGL);
+#else
+	return GFX_SetSDLWindowMode(width, height, false, SCREEN_OPENGL);
+#endif
+}
+
+#endif // SDL_VERSION_ATLEAST(2,0,0)
+
+// Different functions, similar function bodies (SDL 1.2 vs 2.0)
+
+#if SDL_VERSION_ATLEAST(2,0,0)
+static SDL_Window * GFX_SetupWindowScaled(SCREEN_TYPES screenType)
+#else
+static SDL_Surface * GFX_SetupSurfaceScaled(Bit32u sdl_flags, Bit32u bpp)
+#endif
+{
 	Bit16u fixedWidth;
 	Bit16u fixedHeight;
 
@@ -470,11 +746,15 @@
 	if (sdl.desktop.fullscreen) {
 		fixedWidth = sdl.desktop.full.fixed ? sdl.desktop.full.width : 0;
 		fixedHeight = sdl.desktop.full.fixed ? sdl.desktop.full.height : 0;
+#if !SDL_VERSION_ATLEAST(2,0,0)
 		sdl_flags |= SDL_FULLSCREEN|SDL_HWSURFACE;
+#endif
 	} else {
 		fixedWidth = sdl.desktop.window.width;
 		fixedHeight = sdl.desktop.window.height;
+#if !SDL_VERSION_ATLEAST(2,0,0)
 		sdl_flags |= SDL_HWSURFACE;
+#endif
 	}
 	if (fixedWidth && fixedHeight) {
 		double ratio_w=(double)fixedWidth/(sdl.draw.width*sdl.draw.scalex);
@@ -490,27 +770,59 @@
 			sdl.clip.w=(Bit16u)(sdl.draw.width*sdl.draw.scalex*ratio_h + 0.4);
 			sdl.clip.h=(Bit16u)fixedHeight;
 		}
-		if (sdl.desktop.fullscreen)
+		if (sdl.desktop.fullscreen) {
+#if SDL_VERSION_ATLEAST(2,0,0)
+			sdl.window = GFX_SetSDLWindowMode(fixedWidth, fixedHeight, sdl.desktop.fullscreen, screenType);
+#else
 			sdl.surface = SDL_SetVideoMode_Wrap(fixedWidth,fixedHeight,bpp,sdl_flags);
-		else
+#endif
+		} else {
+#if SDL_VERSION_ATLEAST(2,0,0)
+			sdl.window = GFX_SetSDLWindowMode(sdl.clip.w, sdl.clip.h, sdl.desktop.fullscreen, screenType);
+#else
 			sdl.surface = SDL_SetVideoMode_Wrap(sdl.clip.w,sdl.clip.h,bpp,sdl_flags);
+#endif
+		}
+#if SDL_VERSION_ATLEAST(2,0,0)
+		if (sdl.window && SDL_GetWindowFlags(sdl.window) & SDL_WINDOW_FULLSCREEN) {
+			int windowWidth;
+			SDL_GetWindowSize(sdl.window, &windowWidth, NULL);
+			sdl.clip.x=(Sint16)((windowWidth-sdl.clip.w)/2);
+#else
 		if (sdl.surface && sdl.surface->flags & SDL_FULLSCREEN) {
 			sdl.clip.x=(Sint16)((sdl.surface->w-sdl.clip.w)/2);
-			sdl.clip.y=(Sint16)((sdl.surface->h-sdl.clip.h)/2);
+#endif
+#ifdef __ANDROID__
+			/* Portrait orientation and on-screen keyboards
+			are commonly found on that platform          */
+			sdl.clip.y=0;
+#else
+			sdl.clip.y=(Sint16)((fixedHeight-sdl.clip.h)/2);
+#endif
 		} else {
 			sdl.clip.x = 0;
 			sdl.clip.y = 0;
 		}
+#if SDL_VERSION_ATLEAST(2,0,0)
+		return sdl.window;
+#else
 		return sdl.surface;
+#endif
 	} else {
 		sdl.clip.x=0;sdl.clip.y=0;
 		sdl.clip.w=(Bit16u)(sdl.draw.width*sdl.draw.scalex);
 		sdl.clip.h=(Bit16u)(sdl.draw.height*sdl.draw.scaley);
+#if SDL_VERSION_ATLEAST(2,0,0)
+		sdl.window = GFX_SetSDLWindowMode(sdl.clip.w, sdl.clip.h, sdl.desktop.fullscreen, screenType);
+		return sdl.window;
+#else
 		sdl.surface=SDL_SetVideoMode_Wrap(sdl.clip.w,sdl.clip.h,bpp,sdl_flags);
 		return sdl.surface;
+#endif
 	}
 }
 
+#if !SDL_VERSION_ATLEAST(2,0,0) // NOTE: Do we need this? Never used and can't be used as-is with SDL 2.0
 void GFX_TearDown(void) {
 	if (sdl.updating)
 		GFX_EndUpdate( 0 );
@@ -520,6 +832,7 @@
 		sdl.blit.surface=0;
 	}
 }
+#endif
 
 Bitu GFX_SetSize(Bitu width,Bitu height,Bitu flags,double scalex,double scaley,GFX_CallBack_t callback) {
 	if (sdl.updating)
@@ -531,20 +844,24 @@
 	sdl.draw.scalex=scalex;
 	sdl.draw.scaley=scaley;
 
+	Bitu retFlags = 0;
+#if !SDL_VERSION_ATLEAST(2,0,0)
 	int bpp=0;
-	Bitu retFlags = 0;
 
 	if (sdl.blit.surface) {
 		SDL_FreeSurface(sdl.blit.surface);
 		sdl.blit.surface=0;
 	}
+#endif
 	switch (sdl.desktop.want_type) {
 	case SCREEN_SURFACE:
 dosurface:
+#if !SDL_VERSION_ATLEAST(2,0,0)
 		if (flags & GFX_CAN_8) bpp=8;
 		if (flags & GFX_CAN_15) bpp=15;
 		if (flags & GFX_CAN_16) bpp=16;
 		if (flags & GFX_CAN_32) bpp=32;
+#endif
 		sdl.desktop.type=SCREEN_SURFACE;
 		sdl.clip.w=width;
 		sdl.clip.h=height;
@@ -551,21 +868,53 @@
 		if (sdl.desktop.fullscreen) {
 			if (sdl.desktop.full.fixed) {
 				sdl.clip.x=(Sint16)((sdl.desktop.full.width-width)/2);
+#ifdef __ANDROID__
+				/* Portrait orientation and on-screen keyboards
+				are commonly found on that platform          */
+				sdl.clip.y=0;
+#else
 				sdl.clip.y=(Sint16)((sdl.desktop.full.height-height)/2);
+#endif
+#if SDL_VERSION_ATLEAST(2,0,0)
+				sdl.window = GFX_SetSDLWindowMode(sdl.desktop.full.width,
+				                                  sdl.desktop.full.height,
+				                                  sdl.desktop.fullscreen, sdl.desktop.type);
+				if (sdl.window == NULL)
+					E_Exit("Could not set fullscreen video mode %ix%i-%i: %s",sdl.desktop.full.width,sdl.desktop.full.height,sdl.desktop.bpp,SDL_GetError());
+				/* This may be required after an ALT-TAB leading to a window
+				minimize, which further effectively shrinks its size */
+				if ((sdl.clip.x < 0) || (sdl.clip.y < 0)) {
+					sdl.update_display_contents = false;
+				}
+#else
 				sdl.surface=SDL_SetVideoMode_Wrap(sdl.desktop.full.width,sdl.desktop.full.height,bpp,
 					SDL_FULLSCREEN | ((flags & GFX_CAN_RANDOM) ? SDL_SWSURFACE : SDL_HWSURFACE) |
-					(sdl.desktop.doublebuf ? SDL_DOUBLEBUF|SDL_ASYNCBLIT : 0) | SDL_HWPALETTE);
+					(sdl.desktop.vsync ? SDL_DOUBLEBUF|SDL_ASYNCBLIT : 0) | SDL_HWPALETTE);
 				if (sdl.surface == NULL) E_Exit("Could not set fullscreen video mode %ix%i-%i: %s",sdl.desktop.full.width,sdl.desktop.full.height,bpp,SDL_GetError());
+#endif
 			} else {
 				sdl.clip.x=0;sdl.clip.y=0;
+#if SDL_VERSION_ATLEAST(2,0,0)
+				sdl.window = GFX_SetSDLWindowMode(width, height,
+				                                  sdl.desktop.fullscreen, sdl.desktop.type);
+				if (sdl.window == NULL)
+					E_Exit("Could not set fullscreen video mode %ix%i-%i: %s",(int)width,(int)height,sdl.desktop.bpp,SDL_GetError());
+#else
 				sdl.surface=SDL_SetVideoMode_Wrap(width,height,bpp,
 					SDL_FULLSCREEN | ((flags & GFX_CAN_RANDOM) ? SDL_SWSURFACE : SDL_HWSURFACE) |
-					(sdl.desktop.doublebuf ? SDL_DOUBLEBUF|SDL_ASYNCBLIT  : 0)|SDL_HWPALETTE);
+					(sdl.desktop.vsync ? SDL_DOUBLEBUF|SDL_ASYNCBLIT  : 0)|SDL_HWPALETTE);
 				if (sdl.surface == NULL)
 					E_Exit("Could not set fullscreen video mode %ix%i-%i: %s",(int)width,(int)height,bpp,SDL_GetError());
+#endif
 			}
 		} else {
 			sdl.clip.x=0;sdl.clip.y=0;
+#if SDL_VERSION_ATLEAST(2,0,0)
+			sdl.window = GFX_SetSDLWindowMode(width, height,
+			                                  sdl.desktop.fullscreen, sdl.desktop.type);
+			if (sdl.window == NULL)
+				E_Exit("Could not set windowed video mode %ix%i-%i: %s",(int)width,(int)height,sdl.desktop.bpp,SDL_GetError());
+#else
 			sdl.surface=SDL_SetVideoMode_Wrap(width,height,bpp,(flags & GFX_CAN_RANDOM) ? SDL_SWSURFACE : SDL_HWSURFACE);
 #ifdef WIN32
 			if (sdl.surface == NULL) {
@@ -587,42 +936,116 @@
 #endif
 			if (sdl.surface == NULL)
 				E_Exit("Could not set windowed video mode %ix%i-%i: %s",(int)width,(int)height,bpp,SDL_GetError());
+#endif	// !SDL_VERSION_ATLEAST(2,0,0)
 		}
-		if (sdl.surface) {
-			switch (sdl.surface->format->BitsPerPixel) {
+#if SDL_VERSION_ATLEAST(2,0,0)
+		sdl.surface = SDL_GetWindowSurface(sdl.window);
+		if (sdl.surface == NULL)
+			E_Exit("Could not retrieve window surface: %s",SDL_GetError());
+#endif
+		switch (sdl.surface->format->BitsPerPixel) {
 			case 8:
 				retFlags = GFX_CAN_8;
-                break;
+				break;
 			case 15:
 				retFlags = GFX_CAN_15;
 				break;
 			case 16:
 				retFlags = GFX_CAN_16;
-                break;
+				break;
 			case 32:
 				retFlags = GFX_CAN_32;
-                break;
-			}
-			if (retFlags && (sdl.surface->flags & SDL_HWSURFACE))
-				retFlags |= GFX_HARDWARE;
-			if (retFlags && (sdl.surface->flags & SDL_DOUBLEBUF)) {
-				sdl.blit.surface=SDL_CreateRGBSurface(SDL_HWSURFACE,
-					sdl.draw.width, sdl.draw.height,
-					sdl.surface->format->BitsPerPixel,
-					sdl.surface->format->Rmask,
-					sdl.surface->format->Gmask,
-					sdl.surface->format->Bmask,
-				0);
-				/* If this one fails be ready for some flickering... */
-			}
+				break;
 		}
+#if SDL_VERSION_ATLEAST(2,0,0)
+		/* Fix a glitch with aspect=true occuring when
+		changing between modes with different dimensions */
+		SDL_FillRect(sdl.surface, NULL, SDL_MapRGB(sdl.surface->format, 0, 0, 0));
+		SDL_UpdateWindowSurface(sdl.window);
+#else
+		if (retFlags && (sdl.surface->flags & SDL_HWSURFACE))
+			retFlags |= GFX_HARDWARE;
+		if (retFlags && (sdl.surface->flags & SDL_DOUBLEBUF)) {
+			sdl.blit.surface=SDL_CreateRGBSurface(SDL_HWSURFACE,
+				sdl.draw.width, sdl.draw.height,
+				sdl.surface->format->BitsPerPixel,
+				sdl.surface->format->Rmask,
+				sdl.surface->format->Gmask,
+				sdl.surface->format->Bmask,
+			0);
+			/* If this one fails be ready for some flickering... */
+		}
+#endif
 		break;
+#if SDL_VERSION_ATLEAST(2,0,0)
+	case SCREEN_TEXTURE:
+	{
+		if (!GFX_SetupWindowScaled(sdl.desktop.want_type)) {
+			LOG_MSG("SDL:Can't set video mode, falling back to surface");
+			goto dosurface;
+		}
+		if (strcmp(sdl.rendererDriver, "auto"))
+			SDL_SetHint(SDL_HINT_RENDER_DRIVER, sdl.rendererDriver); 
+		sdl.renderer = SDL_CreateRenderer(sdl.window, -1,
+		                                  SDL_RENDERER_ACCELERATED |
+		                                  (sdl.desktop.vsync ? SDL_RENDERER_PRESENTVSYNC : 0));
+		if (!sdl.renderer) {
+			LOG_MSG("%s\n", SDL_GetError());
+			LOG_MSG("SDL:Can't create renderer, falling back to surface");
+			goto dosurface;
+		}
+		/* SDL_PIXELFORMAT_ARGB8888 is possible with most
+		rendering drivers, "opengles" being a notable exception */
+		sdl.texture.texture = SDL_CreateTexture(sdl.renderer, SDL_PIXELFORMAT_ARGB8888,
+		                                        SDL_TEXTUREACCESS_STREAMING, width, height);
+		/* SDL_PIXELFORMAT_ABGR8888 (not RGB) is the
+		only supported format for the "opengles" driver */
+		if (!sdl.texture.texture) {
+			if (flags & GFX_RGBONLY) goto dosurface;
+			sdl.texture.texture = SDL_CreateTexture(sdl.renderer, SDL_PIXELFORMAT_ABGR8888,
+			                                        SDL_TEXTUREACCESS_STREAMING, width, height);
+		}
+		if (!sdl.texture.texture) {
+			SDL_DestroyRenderer(sdl.renderer);
+			sdl.renderer = NULL;
+			LOG_MSG("SDL:Can't create texture, falling back to surface");
+			goto dosurface;
+		}
+		SDL_SetRenderDrawColor(sdl.renderer, 0, 0, 0, SDL_ALPHA_OPAQUE);
+		sdl.desktop.type=SCREEN_TEXTURE;
+		Uint32 pixelFormat;
+		SDL_QueryTexture(sdl.texture.texture, &pixelFormat, NULL, NULL, NULL);
+		sdl.texture.pixelFormat = SDL_AllocFormat(pixelFormat);
+		switch (SDL_BITSPERPIXEL(pixelFormat)) {
+			case 8:
+				retFlags = GFX_CAN_8;
+				break;
+			case 15:
+				retFlags = GFX_CAN_15;
+				break;
+			case 16:
+				retFlags = GFX_CAN_16;
+				break;
+			case 24: /* SDL_BYTESPERPIXEL is probably 4, though. */
+			case 32:
+				retFlags = GFX_CAN_32;
+				break;
+		}
+		retFlags |= GFX_SCALING;
+		SDL_RendererInfo rendererInfo;
+		SDL_GetRendererInfo(sdl.renderer, &rendererInfo);
+		LOG_MSG("Using driver \"%s\" for renderer", rendererInfo.name);
+		if (rendererInfo.flags & SDL_RENDERER_ACCELERATED)
+			retFlags |= GFX_HARDWARE;
+		break;
+	}
+#else	// !SDL_VERSION_ATLEAST(2,0,0)
 #if C_DDRAW
 	case SCREEN_SURFACE_DDRAW:
 		if (flags & GFX_CAN_15) bpp=15;
 		if (flags & GFX_CAN_16) bpp=16;
 		if (flags & GFX_CAN_32) bpp=32;
-		if (!GFX_SetupSurfaceScaled((sdl.desktop.doublebuf && sdl.desktop.fullscreen) ? SDL_DOUBLEBUF : 0,bpp)) goto dosurface;
+		if (!GFX_SetupSurfaceScaled((sdl.desktop.vsync && sdl.desktop.fullscreen) ? SDL_DOUBLEBUF : 0,bpp)) goto dosurface;
 		sdl.blit.rect.top=sdl.clip.y;
 		sdl.blit.rect.left=sdl.clip.x;
 		sdl.blit.rect.right=sdl.clip.x+sdl.clip.w;
@@ -670,13 +1093,17 @@
 		sdl.desktop.type=SCREEN_OVERLAY;
 		retFlags = GFX_CAN_32 | GFX_SCALING | GFX_HARDWARE;
 		break;
+#endif	// !SDL_VERSION_ATLEAST(2,0,0)
 #if C_OPENGL
 	case SCREEN_OPENGL:
 	{
+#ifndef __ANDROID__
 		if (sdl.opengl.pixel_buffer_object) {
 			glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_EXT, 0);
 			if (sdl.opengl.buffer) glDeleteBuffersARB(1, &sdl.opengl.buffer);
-		} else if (sdl.opengl.framebuf) {
+		} else
+#endif
+		if (sdl.opengl.framebuf) {
 			free(sdl.opengl.framebuf);
 		}
 		sdl.opengl.framebuf=0;
@@ -687,8 +1114,32 @@
 			goto dosurface;
 		}
 		SDL_GL_SetAttribute( SDL_GL_DOUBLEBUFFER, 1 );
+#ifdef __ANDROID__
+		/* WARNING: OpenGL ES v2.0 is NOT backwards compatible
+		 * with v1.1! For simplicity we force v1.1 for now,
+		 * although v2.0 is probably the better way.
+		 */
+		SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 1);
+		SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 1);
+#endif
+#if SDL_VERSION_ATLEAST(2,0,0)
+		GFX_SetupWindowScaled(sdl.desktop.want_type);
+		/* We may simply use SDL_BYTESPERPIXEL
+		here rather than SDL_BITSPERPIXEL   */
+		if (!sdl.window || SDL_BYTESPERPIXEL(SDL_GetWindowPixelFormat(sdl.window))<2) {
+			LOG_MSG("SDL:OPENGL:Can't open drawing window, are you running in 16bpp(or higher) mode?");
+			goto dosurface;
+		}
+		sdl.opengl.context = SDL_GL_CreateContext(sdl.window);
+		if (sdl.opengl.context == NULL) {
+			LOG_MSG("SDL:OPENGL:Can't create OpenGL context, falling back to surface");
+			goto dosurface;
+		}
+		/* Sync to VBlank if desired */
+		SDL_GL_SetSwapInterval(sdl.desktop.vsync ? 1 : 0);
+#else	// !SDL_VERSION_ATLEAST(2,0,0)
 #if SDL_VERSION_ATLEAST(1, 2, 11)
-		SDL_GL_SetAttribute( SDL_GL_SWAP_CONTROL, 0 );
+		SDL_GL_SetAttribute( SDL_GL_SWAP_CONTROL, sdl.desktop.vsync ? 1 : 0 );
 #endif
 		GFX_SetupSurfaceScaled(SDL_OPENGL,0);
 		if (!sdl.surface || sdl.surface->format->BitsPerPixel<15) {
@@ -695,22 +1146,35 @@
 			LOG_MSG("SDL:OPENGL: Can't open drawing surface, are you running in 16bpp (or higher) mode?");
 			goto dosurface;
 		}
+#endif	// !SDL_VERSION_ATLEAST(2,0,0)
 		/* Create the texture and display list */
+#ifndef __ANDROID__
 		if (sdl.opengl.pixel_buffer_object) {
 			glGenBuffersARB(1, &sdl.opengl.buffer);
 			glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_EXT, sdl.opengl.buffer);
 			glBufferDataARB(GL_PIXEL_UNPACK_BUFFER_EXT, width*height*4, NULL, GL_STREAM_DRAW_ARB);
 			glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_EXT, 0);
-		} else {
+		} else
+#endif
+		{
 			sdl.opengl.framebuf=malloc(width*height*4);		//32 bit color
 		}
 		sdl.opengl.pitch=width*4;
 
-		if(sdl.clip.x ==0 && sdl.clip.y ==0 && sdl.desktop.fullscreen && !sdl.desktop.full.fixed && (sdl.clip.w != sdl.surface->w || sdl.clip.h != sdl.surface->h)) { 
-//			LOG_MSG("attempting to fix the centering to %d %d %d %d",(sdl.surface->w-sdl.clip.w)/2,(sdl.surface->h-sdl.clip.h)/2,sdl.clip.w,sdl.clip.h);
-			glViewport((sdl.surface->w-sdl.clip.w)/2,(sdl.surface->h-sdl.clip.h)/2,sdl.clip.w,sdl.clip.h);
+#if SDL_VERSION_ATLEAST(2,0,0)
+		int windowWidth, windowHeight;
+		SDL_GetWindowSize(sdl.window, &windowWidth, &windowHeight);
+#else
+		int windowWidth = sdl.surface->w, windowHeight = sdl.surface->h;
+#endif
+		if(sdl.clip.x ==0 && sdl.clip.y ==0 && sdl.desktop.fullscreen && !sdl.desktop.full.fixed && (sdl.clip.w != windowWidth || sdl.clip.h != windowHeight)) { 
+//			LOG_MSG("attempting to fix the centering to %d %d %d %d",(windowWidth-sdl.clip.w)/2,(windowHeight-sdl.clip.h)/2,sdl.clip.w,sdl.clip.h);
+			glViewport((windowWidth-sdl.clip.w)/2,(windowHeight-sdl.clip.h)/2,sdl.clip.w,sdl.clip.h);
 		} else {
-			glViewport(sdl.clip.x,sdl.clip.y,sdl.clip.w,sdl.clip.h);
+			/* We don't just pass sdl.clip.y as-is, so we cover the case of non-vertical
+			 * centering on Android (in order to leave room for the on-screen keyboard)
+			 */
+			glViewport(sdl.clip.x,windowHeight-(sdl.clip.y+sdl.clip.h),sdl.clip.w,sdl.clip.h);
 		}		
 
 		glMatrixMode (GL_PROJECTION);
@@ -718,8 +1182,15 @@
  		glGenTextures(1,&sdl.opengl.texture);
 		glBindTexture(GL_TEXTURE_2D,sdl.opengl.texture);
 		// No borders
+#ifdef __ANDROID__
+		/* Plain OpenGL ES (v1.1) has no mention
+		of GL_CLAMP, so use GL_CLAMP_TO_EDGE  */
+		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
+		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
+#else
 		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);
 		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);
+#endif
 		if (!sdl.opengl.bilinear || ( (sdl.clip.h % height) == 0 && (sdl.clip.w % width) == 0) ) {
 			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
 			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
@@ -730,13 +1201,17 @@
 
 		Bit8u* emptytex = new Bit8u[texsize * texsize * 4];
 		memset((void*) emptytex, 0, texsize * texsize * 4);
+#ifdef __ANDROID__	// OpenGL ES
+		glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, texsize, texsize, 0, GL_RGBA, GL_UNSIGNED_BYTE, (const GLvoid*)emptytex);
+#else
 		glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, texsize, texsize, 0, GL_BGRA_EXT, GL_UNSIGNED_BYTE, (const GLvoid*)emptytex);
+#endif
 		delete [] emptytex;
 
 		glClearColor (0.0f, 0.0f, 0.0f, 1.0f);
-		glClear(GL_COLOR_BUFFER_BIT);
+/*		glClear(GL_COLOR_BUFFER_BIT);
 		SDL_GL_SwapBuffers();
-		glClear(GL_COLOR_BUFFER_BIT);
+		glClear(GL_COLOR_BUFFER_BIT);*/
 		glShadeModel (GL_FLAT);
 		glDisable (GL_DEPTH_TEST);
 		glDisable (GL_LIGHTING);
@@ -748,9 +1223,18 @@
 		GLfloat tex_width=((GLfloat)(width)/(GLfloat)texsize);
 		GLfloat tex_height=((GLfloat)(height)/(GLfloat)texsize);
 
+#ifdef __ANDROID__
+		/* Display lists are not available with OpenGL ES (1.0, 2.0).
+		Furthermore, we can't use glBegin, glTexCoord2f and glEnd. */
+		sdl.opengl.texCoords[0] = 0; sdl.opengl.texCoords[1] = tex_height; // lower left
+		sdl.opengl.texCoords[2] = tex_width; sdl.opengl.texCoords[3] = tex_height; // lower right
+		sdl.opengl.texCoords[4] = tex_width; sdl.opengl.texCoords[5] = 0; // upper right
+		sdl.opengl.texCoords[6] = 0; sdl.opengl.texCoords[7] = 0; // upper left
+#else
 		if (glIsList(sdl.opengl.displaylist)) glDeleteLists(sdl.opengl.displaylist, 1);
 		sdl.opengl.displaylist = glGenLists(1);
 		glNewList(sdl.opengl.displaylist, GL_COMPILE);
+		glClear(GL_COLOR_BUFFER_BIT);
 		glBindTexture(GL_TEXTURE_2D, sdl.opengl.texture);
 
 		glBegin(GL_TRIANGLES);
@@ -763,10 +1247,13 @@
 		glEnd();
 
 		glEndList();
+#endif
 		sdl.desktop.type=SCREEN_OPENGL;
 		retFlags = GFX_CAN_32 | GFX_SCALING;
+#ifndef __ANDROID__
 		if (sdl.opengl.pixel_buffer_object)
 			retFlags |= GFX_HARDWARE;
+#endif
 	break;
 		}//OPENGL
 #endif	//C_OPENGL
@@ -780,18 +1267,28 @@
 	return retFlags;
 }
 
+
 void GFX_CaptureMouse(void) {
 	sdl.mouse.locked=!sdl.mouse.locked;
 	if (sdl.mouse.locked) {
+#if SDL_VERSION_ATLEAST(2,0,0)
+		SDL_SetRelativeMouseMode(SDL_TRUE);
+#else
 		SDL_WM_GrabInput(SDL_GRAB_ON);
+#endif
 		SDL_ShowCursor(SDL_DISABLE);
 	} else {
+#if SDL_VERSION_ATLEAST(2,0,0)
+		SDL_SetRelativeMouseMode(SDL_FALSE);
+#else
 		SDL_WM_GrabInput(SDL_GRAB_OFF);
+#endif
 		if (sdl.mouse.autoenable || !sdl.mouse.autolock) SDL_ShowCursor(SDL_ENABLE);
 	}
         mouselocked=sdl.mouse.locked;
 }
 
+#if !SDL_VERSION_ATLEAST(2,0,0) // NOTE: Do we need this?
 void GFX_UpdateSDLCaptureState(void) {
 	if (sdl.mouse.locked) {
 		SDL_WM_GrabInput(SDL_GRAB_ON);
@@ -803,6 +1300,7 @@
 	CPU_Reset_AutoAdjust();
 	GFX_SetTitle(-1,-1,false);
 }
+#endif // SDL 1.2
 
 bool mouselocked; //Global variable for mapper
 static void CaptureMouse(bool pressed) {
@@ -875,25 +1373,36 @@
 	return false;
 }
 
+#if !SDL_VERSION_ATLEAST(2,0,0) // NOTE: Do we need this?
 void GFX_RestoreMode(void) {
 	GFX_SetSize(sdl.draw.width,sdl.draw.height,sdl.draw.flags,sdl.draw.scalex,sdl.draw.scaley,sdl.draw.callback);
 	GFX_UpdateSDLCaptureState();
 }
+#endif
 
 
 bool GFX_StartUpdate(Bit8u * & pixels,Bitu & pitch) {
+#if SDL_VERSION_ATLEAST(2,0,0)
+	if (!sdl.update_display_contents)
+		return false;
+#endif
 	if (!sdl.active || sdl.updating)
 		return false;
 	switch (sdl.desktop.type) {
 	case SCREEN_SURFACE:
+#if !SDL_VERSION_ATLEAST(2,0,0)
 		if (sdl.blit.surface) {
 			if (SDL_MUSTLOCK(sdl.blit.surface) && SDL_LockSurface(sdl.blit.surface))
 				return false;
 			pixels=(Bit8u *)sdl.blit.surface->pixels;
 			pitch=sdl.blit.surface->pitch;
-		} else {
+		} else
+#endif
+		{
+#if !SDL_VERSION_ATLEAST(2,0,0)
 			if (SDL_MUSTLOCK(sdl.surface) && SDL_LockSurface(sdl.surface))
 				return false;
+#endif
 			pixels=(Bit8u *)sdl.surface->pixels;
 			pixels+=sdl.clip.y*sdl.surface->pitch;
 			pixels+=sdl.clip.x*sdl.surface->format->BytesPerPixel;
@@ -901,6 +1410,19 @@
 		}
 		sdl.updating=true;
 		return true;
+#if SDL_VERSION_ATLEAST(2,0,0)
+	case SCREEN_TEXTURE:
+	{
+		void * texPixels;
+		int texPitch;
+		if (SDL_LockTexture(sdl.texture.texture, NULL, &texPixels, &texPitch) < 0)
+			return false;
+		pixels = (Bit8u *)texPixels;
+		pitch = texPitch;
+		sdl.updating=true;
+		return true;
+	}
+#else	// !SDL_VERSION_ATLEAST(2,0,0)
 #if C_DDRAW
 	case SCREEN_SURFACE_DDRAW:
 		if (SDL_LockSurface(sdl.blit.surface)) {
@@ -911,7 +1433,7 @@
 		pitch=sdl.blit.surface->pitch;
 		sdl.updating=true;
 		return true;
-#endif
+#endif	// DirectDraw
 	case SCREEN_OVERLAY:
 		if (SDL_LockYUVOverlay(sdl.overlay)) return false;
 		pixels=(Bit8u *)*(sdl.overlay->pixels);
@@ -918,13 +1440,18 @@
 		pitch=*(sdl.overlay->pitches);
 		sdl.updating=true;
 		return true;
+#endif	// !SDL_VERSION_ATLEAST(2,0,0)
 #if C_OPENGL
 	case SCREEN_OPENGL:
+#ifndef __ANDROID__
 		if(sdl.opengl.pixel_buffer_object) {
 		    glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_EXT, sdl.opengl.buffer);
 		    pixels=(Bit8u *)glMapBufferARB(GL_PIXEL_UNPACK_BUFFER_EXT, GL_WRITE_ONLY);
 		} else
+#endif
+		{
 		    pixels=(Bit8u *)sdl.opengl.framebuf;
+		}
 		pitch=sdl.opengl.pitch;
 		sdl.updating=true;
 		return true;
@@ -940,11 +1467,16 @@
 #if C_DDRAW
 	int ret;
 #endif
+#if SDL_VERSION_ATLEAST(2,0,0)
+	if (!sdl.update_display_contents)
+		return;
+#endif
 	if (!sdl.updating)
 		return;
 	sdl.updating=false;
 	switch (sdl.desktop.type) {
 	case SCREEN_SURFACE:
+#if !SDL_VERSION_ATLEAST(2,0,0)
 		if (SDL_MUSTLOCK(sdl.surface)) {
 			if (sdl.blit.surface) {
 				SDL_UnlockSurface(sdl.blit.surface);
@@ -954,7 +1486,9 @@
 				SDL_UnlockSurface(sdl.surface);
 			}
 			SDL_Flip(sdl.surface);
-		} else if (changedLines) {
+		} else
+#endif
+		if (changedLines) {
 			Bitu y = 0, index = 0, rectCount = 0;
 			while (y < sdl.draw.height) {
 				if (!(index & 1)) {
@@ -975,9 +1509,21 @@
 				index++;
 			}
 			if (rectCount)
+#if SDL_VERSION_ATLEAST(2,0,0)
+				SDL_UpdateWindowSurfaceRects( sdl.window, sdl.updateRects, rectCount );
+#else
 				SDL_UpdateRects( sdl.surface, rectCount, sdl.updateRects );
+#endif
 		}
 		break;
+#if SDL_VERSION_ATLEAST(2,0,0)
+	case SCREEN_TEXTURE:
+		SDL_UnlockTexture(sdl.texture.texture);
+		SDL_RenderClear(sdl.renderer);
+		SDL_RenderCopy(sdl.renderer, sdl.texture.texture, NULL, &sdl.clip);
+		SDL_RenderPresent(sdl.renderer);
+		break;
+#else	// !SDL_VERSION_ATLEAST(2,0,0)
 #if C_DDRAW
 	case SCREEN_SURFACE_DDRAW:
 		SDL_UnlockSurface(sdl.blit.surface);
@@ -997,13 +1543,15 @@
 		}
 		SDL_Flip(sdl.surface);
 		break;
-#endif
+#endif	// DirectDraw
 	case SCREEN_OVERLAY:
 		SDL_UnlockYUVOverlay(sdl.overlay);
 		SDL_DisplayYUVOverlay(sdl.overlay,&sdl.clip);
 		break;
+#endif	// !SDL_VERSION_ATLEAST(2,0,0)
 #if C_OPENGL
 	case SCREEN_OPENGL:
+#ifndef __ANDROID__
 		// Clear drawing area. Some drivers (on Linux) have more than 2 buffers and the screen might
 		// be dirty because of other programs.
 		glClearColor (0.0f, 0.0f, 0.0f, 1.0f);
@@ -1016,8 +1564,14 @@
 					GL_UNSIGNED_INT_8_8_8_8_REV, 0);
 			glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_EXT, 0);
 			glCallList(sdl.opengl.displaylist);
-			SDL_GL_SwapBuffers();
-		} else if (changedLines) {
+#if SDL_VERSION_ATLEAST(2,0,0)
+			SDL_GL_SwapWindow(sdl.window);
+#else
+ 			SDL_GL_SwapBuffers();
+#endif
+		} else
+#endif	// ifndef __ANDROID__
+		if (changedLines) {
 			Bitu y = 0, index = 0;
 			glBindTexture(GL_TEXTURE_2D, sdl.opengl.texture);
 			while (y < sdl.draw.height) {
@@ -1026,15 +1580,43 @@
 				} else {
 					Bit8u *pixels = (Bit8u *)sdl.opengl.framebuf + y * sdl.opengl.pitch;
 					Bitu height = changedLines[index];
+#ifdef __ANDROID__
+					/* Try GL_UNSIGNED_BYTE... */
 					glTexSubImage2D(GL_TEXTURE_2D, 0, 0, y,
+						sdl.draw.width, height, GL_RGBA,
+						GL_UNSIGNED_BYTE, pixels );
+#else
+					glTexSubImage2D(GL_TEXTURE_2D, 0, 0, y,
 						sdl.draw.width, height, GL_BGRA_EXT,
 						GL_UNSIGNED_INT_8_8_8_8_REV, pixels );
+#endif
 					y += height;
 				}
 				index++;
 			}
+#ifdef __ANDROID__
+			/* We can't use display lists with OpenGL ES
+			and we should use Vertex Buffer Arrays    */
+			glClear(GL_COLOR_BUFFER_BIT);
+			glBindTexture(GL_TEXTURE_2D, sdl.opengl.texture);
+
+			glEnableClientState(GL_VERTEX_ARRAY);
+			glEnableClientState(GL_TEXTURE_COORD_ARRAY);
+
+			glVertexPointer(2, GL_FLOAT, 0, sdl.opengl.vertCoords);
+			glTexCoordPointer(2, GL_FLOAT, 0, sdl.opengl.texCoords);
+			glDrawArrays(GL_TRIANGLE_FAN,0,4);
+
+			glDisableClientState(GL_VERTEX_ARRAY);
+			glDisableClientState(GL_TEXTURE_COORD_ARRAY);
+#else	// !__ANDROID__
 			glCallList(sdl.opengl.displaylist);
+#endif	// !__ANDROID__
+#if SDL_VERSION_ATLEAST(2,0,0)
+			SDL_GL_SwapWindow(sdl.window);
+#else
 			SDL_GL_SwapBuffers();
+#endif
 		}
 		break;
 #endif
@@ -1045,6 +1627,7 @@
 
 
 void GFX_SetPalette(Bitu start,Bitu count,GFX_PalEntry * entries) {
+#if !SDL_VERSION_ATLEAST(2,0,0) // NOTE: Better remove this if SDL 1.2 isn't supported?
 	/* I should probably not change the GFX_PalEntry :) */
 	if (sdl.surface->flags & SDL_HWPALETTE) {
 		if (!SDL_SetPalette(sdl.surface,SDL_PHYSPAL,(SDL_Color *)entries,start,count)) {
@@ -1055,13 +1638,20 @@
 			E_Exit("SDL:Can't set palette");
 		}
 	}
+#endif
 }
 
 Bitu GFX_GetRGB(Bit8u red,Bit8u green,Bit8u blue) {
 	switch (sdl.desktop.type) {
 	case SCREEN_SURFACE:
+#if !SDL_VERSION_ATLEAST(2,0,0)
 	case SCREEN_SURFACE_DDRAW:
+#endif
 		return SDL_MapRGB(sdl.surface->format,red,green,blue);
+#if SDL_VERSION_ATLEAST(2,0,0)
+	case SCREEN_TEXTURE:
+		return SDL_MapRGB(sdl.texture.pixelFormat,red,green,blue);
+#else
 	case SCREEN_OVERLAY:
 		{
 			Bit8u y =  ( 9797*(red) + 19237*(green) +  3734*(blue) ) >> 15;
@@ -1073,10 +1663,15 @@
 			return (u << 0) | (y << 8) | (v << 16) | (y << 24);
 #endif
 		}
+#endif	// !SDL_VERSION_ATLEAST(2,0,0)
 	case SCREEN_OPENGL:
-//		return ((red << 0) | (green << 8) | (blue << 16)) | (255 << 24);
-		//USE BGRA
+#ifdef __ANDROID__
+		//Use RGBA on Android with OpenGL ES v1.1
+		return ((red << 0) | (green << 8) | (blue << 16)) | (255 << 24);
+#else
+		//USE BGRA otherwise
 		return ((blue << 0) | (green << 8) | (red << 16)) | (255 << 24);
+#endif
 	}
 	return 0;
 }
@@ -1091,6 +1686,36 @@
 	sdl.active=true;
 }
 
+/* NOTE: The following appears to do its job on Android only *before*
+ * a screen rotation occurs. After that, the old dimensions are retrieved.
+ * For the updated dimensions we should listen to a window resize event.
+ */
+#if SDL_VERSION_ATLEAST(2,0,0)
+void GFX_ObtainDisplayDimensions() {
+	SDL_Rect displayDimensions;
+	SDL_GetDisplayBounds(sdl.displayNumber, &displayDimensions);
+	sdl.desktop.full.width = displayDimensions.w;
+	sdl.desktop.full.height = displayDimensions.h;
+
+}
+
+/* Manually update display dimensions in case of a window resize,
+ * IF there is the need for that ("yes" on Android, "no" otherwise).
+ * Used for the mapper UI on Android.
+ * Reason is the usage of GFX_GetSDLSurfaceSubwindowDims, as well as a
+ * mere notification of the fact that the window's dimensions are modified.
+ */
+void GFX_UpdateDisplayDimensions(int width, int height) {
+	if (sdl.desktop.full.display_res && sdl.desktop.fullscreen) {
+		/* Note: We should not use GFX_ObtainDisplayDimensions
+		(SDL_GetDisplayBounds) on Android after a screen rotation:
+		The older values from application startup are returned. */
+		sdl.desktop.full.width = width;
+		sdl.desktop.full.height = height;
+	}
+}
+#endif
+
 static void GUI_ShutDown(Section * /*sec*/) {
 	GFX_Stop();
 	if (sdl.draw.callback) (sdl.draw.callback)( GFX_CallBackStop );
@@ -1181,6 +1806,10 @@
 	Section_prop * section=static_cast<Section_prop *>(sec);
 	sdl.active=false;
 	sdl.updating=false;
+#if SDL_VERSION_ATLEAST(2,0,0)
+	sdl.resizing_window=false;
+	sdl.update_display_contents=true;
+#endif
 
 	GFX_SetIcon();
 
@@ -1187,7 +1816,11 @@
 	sdl.desktop.lazy_fullscreen=false;
 	sdl.desktop.lazy_fullscreen_req=false;
 
+#ifdef __ANDROID__
+	sdl.desktop.fullscreen=true;
+#else
 	sdl.desktop.fullscreen=section->Get_bool("fullscreen");
+#endif
 	sdl.wait_on_error=section->Get_bool("waitonerror");
 
 	Prop_multival* p=section->Get_multival("priority");
@@ -1216,10 +1849,18 @@
 	sdl.mouse.locked=false;
 	mouselocked=false; //Global for mapper
 	sdl.mouse.requestlock=false;
+#ifdef __ANDROID__
+	sdl.mouse.isLeftMouseFingerUsed=sdl.mouse.isRightMouseFingerUsed=false;
+	sdl.mouse.isMiddleMouseFingerUsed=sdl.mouse.isEscKeyFingerUsed=false;
+	/* We force fullscreen desktop resolution */
+	sdl.desktop.full.fixed=true;
+#else
 	sdl.desktop.full.fixed=false;
 	const char* fullresolution=section->Get_string("fullresolution");
+#endif
 	sdl.desktop.full.width  = 0;
 	sdl.desktop.full.height = 0;
+#ifndef __ANDROID__
 	if(fullresolution && *fullresolution) {
 		char res[100];
 		safe_strncpy( res, fullresolution, sizeof( res ));
@@ -1236,9 +1877,10 @@
 			}
 		}
 	}
-
+#endif
 	sdl.desktop.window.width  = 0;
 	sdl.desktop.window.height = 0;
+#ifndef __ANDROID__
 	const char* windowresolution=section->Get_string("windowresolution");
 	if(windowresolution && *windowresolution) {
 		char res[100];
@@ -1253,7 +1895,24 @@
 			}
 		}
 	}
-	sdl.desktop.doublebuf=section->Get_bool("fulldouble");
+#endif
+
+	sdl.desktop.vsync=section->Get_bool("vsync");
+
+#if SDL_VERSION_ATLEAST(2,0,0)
+
+	sdl.displayNumber=section->Get_int("display");
+	if ((sdl.displayNumber < 0) || (sdl.displayNumber >= SDL_GetNumVideoDisplays())) {
+		sdl.displayNumber = 0;
+		LOG_MSG("SDL:Display number out of bounds, switching back to 0");
+	}
+	sdl.desktop.full.display_res = sdl.desktop.full.fixed && (!sdl.desktop.full.width || !sdl.desktop.full.height);
+	if (sdl.desktop.full.display_res) {
+		GFX_ObtainDisplayDimensions();
+	}
+
+#else	// !SDL_VERSION_ATLEAST(2,0,0)
+
 #if SDL_VERSION_ATLEAST(1, 2, 10)
 #ifdef WIN32
 	const SDL_VideoInfo* vidinfo = SDL_GetVideoInfo();
@@ -1294,6 +1953,8 @@
 		sdl.desktop.full.height=768;
 #endif
 	}
+#endif	// !SDL_VERSION_ATLEAST(2,0,0)
+
 	sdl.mouse.autoenable=section->Get_bool("autolock");
 	if (!sdl.mouse.autoenable) SDL_ShowCursor(SDL_DISABLE);
 	sdl.mouse.autolock=false;
@@ -1308,6 +1969,15 @@
 
 	if (output == "surface") {
 		sdl.desktop.want_type=SCREEN_SURFACE;
+#if SDL_VERSION_ATLEAST(2,0,0)
+	} else if (output == "texture") {
+		sdl.desktop.want_type=SCREEN_TEXTURE;
+		SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "linear");
+	} else if (output == "texturenb") {
+		sdl.desktop.want_type=SCREEN_TEXTURE;
+		// Currently the default, but... oh well
+		SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, "nearest");
+#else	// !SDL_VERSION_ATLEAST(2,0,0)
 #if C_DDRAW
 	} else if (output == "ddraw") {
 		sdl.desktop.want_type=SCREEN_SURFACE_DDRAW;
@@ -1314,6 +1984,7 @@
 #endif
 	} else if (output == "overlay") {
 		sdl.desktop.want_type=SCREEN_OVERLAY;
+#endif	// !SDL_VERSION_ATLEAST(2,0,0)
 #if C_OPENGL
 	} else if (output == "opengl") {
 		sdl.desktop.want_type=SCREEN_OPENGL;
@@ -1327,19 +1998,56 @@
 		sdl.desktop.want_type=SCREEN_SURFACE;//SHOULDN'T BE POSSIBLE anymore
 	}
 
+#if SDL_VERSION_ATLEAST(2,0,0)
+	sdl.texture.texture=0;
+	sdl.texture.pixelFormat=0;
+	sdl.window=0;
+	sdl.renderer=0;
+	sdl.rendererDriver = section->Get_string("renderer");
+#else
 	sdl.overlay=0;
+#endif
+
+#if (defined C_OPENGL) && (defined __ANDROID__) // OpenGL ES
+	static const GLfloat vertCoords[] = {
+	-1, -1, //  lower left
+	1, -1, // lower right
+	1, 1, // upper right
+	-1, 1 // upper left
+	};
+	memcpy(sdl.opengl.vertCoords, vertCoords, sizeof(vertCoords));
+#endif
+
 #if C_OPENGL
    if(sdl.desktop.want_type==SCREEN_OPENGL){ /* OPENGL is requested */
+#if SDL_VERSION_ATLEAST(2,0,0)
+	if (!GFX_SetSDLOpenGLWindow(640,400)) {
+		LOG_MSG("Could not create OpenGL window, switching back to surface");
+		sdl.desktop.want_type=SCREEN_SURFACE;
+	} else {
+		sdl.opengl.context = SDL_GL_CreateContext(sdl.window);
+		if (sdl.opengl.context == 0) {
+			LOG_MSG("Could not create OpenGL context, switching back to surface");
+			sdl.desktop.want_type=SCREEN_SURFACE;
+		}
+	}
+	if (sdl.desktop.want_type==SCREEN_OPENGL) {
+#else	// Same story but for SDL 1.2
 	sdl.surface=SDL_SetVideoMode_Wrap(640,400,0,SDL_OPENGL);
 	if (sdl.surface == NULL) {
 		LOG_MSG("Could not initialize OpenGL, switching back to surface");
 		sdl.desktop.want_type=SCREEN_SURFACE;
 	} else {
+#endif	// End of SDL specific video mode check. Let's assume it has passed...
 	sdl.opengl.buffer=0;
 	sdl.opengl.framebuf=0;
 	sdl.opengl.texture=0;
+#ifndef __ANDROID__
 	sdl.opengl.displaylist=0;
+#endif
+
 	glGetIntegerv (GL_MAX_TEXTURE_SIZE, &sdl.opengl.max_texsize);
+#ifndef __ANDROID__
 	glGenBuffersARB = (PFNGLGENBUFFERSARBPROC)SDL_GL_GetProcAddress("glGenBuffersARB");
 	glBindBufferARB = (PFNGLBINDBUFFERARBPROC)SDL_GL_GetProcAddress("glBindBufferARB");
 	glDeleteBuffersARB = (PFNGLDELETEBUFFERSARBPROC)SDL_GL_GetProcAddress("glDeleteBuffersARB");
@@ -1356,19 +2064,38 @@
     	} else {
 		sdl.opengl.packed_pixel=sdl.opengl.paletted_texture=false;
 	}
+#endif	// ifndef __ANDROID__
 	}
 	} /* OPENGL is requested end */
 
 #endif	//OPENGL
 	/* Initialize screen for first time */
+#if SDL_VERSION_ATLEAST(2,0,0)
+	if (!GFX_SetSDLSurfaceWindow(640,400))
+		E_Exit("Could not initialize video: %s",SDL_GetError());
+	sdl.surface = SDL_GetWindowSurface(sdl.window);
+	if (sdl.surface == NULL) E_Exit("Could not retrieve window surface: %s",SDL_GetError());
+	SDL_Rect splash_rect=GFX_GetSDLSurfaceSubwindowDims(640,400);
+	sdl.desktop.sdl2pixelFormat = sdl.surface->format->format;
+	LOG_MSG("SDL:Current window pixel format: %s", SDL_GetPixelFormatName(sdl.desktop.sdl2pixelFormat));
+	/* Do NOT use SDL_BITSPERPIXEL here - It returns 24 for
+	SDL_PIXELFORMAT_RGB888, while SDL_BYTESPERPIXEL returns 4.
+	To compare, with SDL 1.2 the detected desktop color depth is 32 bpp. */
+	sdl.desktop.bpp=8*SDL_BYTESPERPIXEL(sdl.desktop.sdl2pixelFormat);
+#else
 	sdl.surface=SDL_SetVideoMode_Wrap(640,400,0,0);
 	if (sdl.surface == NULL) E_Exit("Could not initialize video: %s",SDL_GetError());
 	sdl.desktop.bpp=sdl.surface->format->BitsPerPixel;
+#endif
 	if (sdl.desktop.bpp==24) {
 		LOG_MSG("SDL: You are running in 24 bpp mode, this will slow down things!");
 	}
 	GFX_Stop();
+#if SDL_VERSION_ATLEAST(2,0,0)
+	SDL_SetWindowTitle(sdl.window,"DOSBox");
+#else
 	SDL_WM_SetCaption("DOSBox",VERSION);
+#endif
 
 /* The endian part is intentionally disabled as somehow it produces correct results without according to rhoenie*/
 //#if SDL_BYTEORDER == SDL_BIG_ENDIAN
@@ -1384,6 +2111,9 @@
 /* Please leave the Splash screen stuff in working order in DOSBox. We spend a lot of time making DOSBox. */
 	SDL_Surface* splash_surf = SDL_CreateRGBSurface(SDL_SWSURFACE, 640, 400, 32, rmask, gmask, bmask, 0);
 	if (splash_surf) {
+#if SDL_VERSION_ATLEAST(2,0,0)
+		SDL_SetSurfaceBlendMode(splash_surf, SDL_BLENDMODE_BLEND);
+#endif
 		SDL_FillRect(splash_surf, NULL, SDL_MapRGB(splash_surf->format, 0, 0, 0));
 
 		Bit8u* tmpbufp = new Bit8u[640*400*3];
@@ -1419,16 +2149,40 @@
 
 			if (ct<1) {
 				SDL_FillRect(sdl.surface, NULL, SDL_MapRGB(sdl.surface->format, 0, 0, 0));
+#if SDL_VERSION_ATLEAST(2,0,0)
+				SDL_SetSurfaceAlphaMod(splash_surf, 255);
+				SDL_BlitScaled(splash_surf, NULL, sdl.surface, &splash_rect);
+#else
 				SDL_SetAlpha(splash_surf, SDL_SRCALPHA,255);
 				SDL_BlitSurface(splash_surf, NULL, sdl.surface, NULL);
+#endif
+#if SDL_VERSION_ATLEAST(2,0,0)
+				SDL_UpdateWindowSurface(sdl.window);
+#else
 				SDL_Flip(sdl.surface);
+#endif
 			} else if (ct>=max_splash_loop-splash_fade) {
 				if (use_fadeout) {
 					SDL_FillRect(sdl.surface, NULL, SDL_MapRGB(sdl.surface->format, 0, 0, 0));
+#if SDL_VERSION_ATLEAST(2,0,0)
+					SDL_SetSurfaceAlphaMod(splash_surf, (Bit8u)((max_splash_loop-1-ct)*255/(splash_fade-1)));
+					SDL_BlitScaled(splash_surf, NULL, sdl.surface, &splash_rect);
+#else
 					SDL_SetAlpha(splash_surf, SDL_SRCALPHA, (Bit8u)((max_splash_loop-1-ct)*255/(splash_fade-1)));
 					SDL_BlitSurface(splash_surf, NULL, sdl.surface, NULL);
+#endif
+#if SDL_VERSION_ATLEAST(2,0,0)
+					SDL_UpdateWindowSurface(sdl.window);
+#else
 					SDL_Flip(sdl.surface);
+#endif
 				}
+			} else { // Fix a possible glitch
+#if SDL_VERSION_ATLEAST(2,0,0)
+				SDL_UpdateWindowSurface(sdl.window);
+#else
+				SDL_Flip(sdl.surface);
+#endif
 			}
 
 		}
@@ -1435,7 +2189,11 @@
 
 		if (use_fadeout) {
 			SDL_FillRect(sdl.surface, NULL, SDL_MapRGB(sdl.surface->format, 0, 0, 0));
+#if SDL_VERSION_ATLEAST(2,0,0)
+			SDL_UpdateWindowSurface(sdl.window);
+#else
 			SDL_Flip(sdl.surface);
+#endif
 		}
 		SDL_FreeSurface(splash_surf);
 		delete [] tmpbufp;
@@ -1453,7 +2211,11 @@
 	MAPPER_AddHandler(&PauseDOSBox, MK_pause, MMOD2, "pause", "Pause DBox");
 #endif
 	/* Get Keyboard state of numlock and capslock */
+#if SDL_VERSION_ATLEAST(2,0,0)
+	SDL_Keymod keystate = SDL_GetModState();
+#else
 	SDLMod keystate = SDL_GetModState();
+#endif
 	if(keystate&KMOD_NUM) startup_state_numlock = true;
 	if(keystate&KMOD_CAPS) startup_state_capslock = true;
 }
@@ -1467,6 +2229,83 @@
 	}
 }
 
+#if defined(__ANDROID__)
+/* The way mouse emulation is done here is based on the
+following (horizontal) partitioning of the touchscreen:
+
+/-----------------------------------------------------------------------\
+|    Left   | (H)Escape |   Motion  |  Motion   |   Middle  |   Right   |
+\-----------------------------------------------------------------------/
+
+Note that the simulated Escape key is the host one
+(not the emulator's), so it can be re-mapped.
+Furthermore, that should be considered a hack for now. */
+static void HandleTouchFinger(SDL_TouchFingerEvent * tfinger) {
+	void MAPPER_CheckEvent(SDL_Event * event);
+	switch (tfinger->type) {
+		case SDL_FINGERDOWN:
+			if (tfinger->x >= 0.83f) { // Right button
+				sdl.mouse.rightMouseFingerID = tfinger->fingerId;
+				if (!sdl.mouse.isRightMouseFingerUsed) {
+					Mouse_ButtonPressed(1);
+					sdl.mouse.isRightMouseFingerUsed = true;
+				}
+			} else if (tfinger->x >= 0.67f) { // Middle button
+				sdl.mouse.middleMouseFingerID = tfinger->fingerId;
+				if (!sdl.mouse.isMiddleMouseFingerUsed) {
+					Mouse_ButtonPressed(2);
+					sdl.mouse.isMiddleMouseFingerUsed = true;
+				}
+			} else if (tfinger->x >= 0.33f) { // Motion
+				sdl.mouse.mouseMotionFingerID = tfinger->fingerId;
+			} else if (tfinger->x >= 0.17f) { // (Host) Escape key
+				sdl.mouse.escKeyFingerID = tfinger->fingerId;
+				if (!sdl.mouse.isEscKeyFingerUsed) {
+					SDL_Event event;
+					event.type = SDL_KEYDOWN;
+					event.key.keysym.scancode = SDL_SCANCODE_ESCAPE;
+					MAPPER_CheckEvent(&event);
+					sdl.mouse.isEscKeyFingerUsed = true;
+				}
+			} else { // Left button
+				sdl.mouse.leftMouseFingerID = tfinger->fingerId;
+				if (!sdl.mouse.isLeftMouseFingerUsed) {
+					Mouse_ButtonPressed(0);
+					sdl.mouse.isLeftMouseFingerUsed = true;
+				}
+			}
+			break;
+		case SDL_FINGERUP:
+			if ((sdl.mouse.leftMouseFingerID == tfinger->fingerId) && sdl.mouse.isLeftMouseFingerUsed) {
+				Mouse_ButtonReleased(0);
+				sdl.mouse.isLeftMouseFingerUsed = false;
+			} else if ((sdl.mouse.rightMouseFingerID == tfinger->fingerId) && sdl.mouse.isRightMouseFingerUsed) {
+				Mouse_ButtonReleased(1);
+				sdl.mouse.isRightMouseFingerUsed = false;
+			} else if ((sdl.mouse.middleMouseFingerID == tfinger->fingerId) && sdl.mouse.isMiddleMouseFingerUsed) {
+				Mouse_ButtonReleased(2);
+				sdl.mouse.isMiddleMouseFingerUsed = false;
+			} else if ((sdl.mouse.escKeyFingerID == tfinger->fingerId) && sdl.mouse.isEscKeyFingerUsed) {
+				SDL_Event event;
+				event.type = SDL_KEYUP;
+				event.key.keysym.scancode = SDL_SCANCODE_ESCAPE;
+				MAPPER_CheckEvent(&event);
+				sdl.mouse.isEscKeyFingerUsed = false;
+			}
+			break;
+		case SDL_FINGERMOTION:
+			/* We basically IGNORE the absolute coordinates, since
+			we emulate relative mouse movement all the time.    */
+			if (sdl.mouse.mouseMotionFingerID == tfinger->fingerId) {
+				Mouse_CursorMoved((float)tfinger->dx*sdl.clip.w*sdl.mouse.sensitivity/100.0f,
+				                  (float)tfinger->dy*sdl.clip.h*sdl.mouse.sensitivity/100.0f,
+				                  0, 0, true);
+			}
+			break;
+	}
+}
+
+#else	// Not on Android
 static void HandleMouseMotion(SDL_MouseMotionEvent * motion) {
 	if (sdl.mouse.locked || !sdl.mouse.autoenable)
 		Mouse_CursorMoved((float)motion->xrel*sdl.mouse.xsensitivity/100.0f,
@@ -1515,6 +2354,7 @@
 		break;
 	}
 }
+#endif	// End of touch/mouse differentiation
 
 void GFX_LosingFocus(void) {
 	sdl.laltstate=SDL_KEYUP;
@@ -1533,12 +2373,40 @@
 #define DB_POLLSKIP 1
 #endif
 
-#if defined(LINUX)
+#if (defined(LINUX) && !SDL_VERSION_ATLEAST(2,0,0))
 #define SDL_XORG_FIX 1
 #else
 #define SDL_XORG_FIX 0
 #endif
 
+#if SDL_VERSION_ATLEAST(2,0,0)
+void GFX_HandleVideoResize(int width, int height) {
+	/* Maybe a screen rotation has just occurred, so we simply resize.
+	There may be a different cause for a forced resized, though.    */
+	if (sdl.desktop.full.display_res && sdl.desktop.fullscreen) {
+		/* Note: We should not use GFX_ObtainDisplayDimensions
+		(SDL_GetDisplayBounds) on Android after a screen rotation:
+		The older values from application startup are returned. */
+		sdl.desktop.full.width = width;
+		sdl.desktop.full.height = height;
+	}
+	/* Even if the new window's dimensions are actually the desired ones
+	 * we may still need to re-obtain a new window surface or do
+	 * a different thing. So we basically reset the screen, but without
+	 * touching the window itself (or else we may end in an infinite loop).
+	 *
+	 * Furthermore, if the new dimensions are *not* the desired ones, we
+	 * don't fight it. Rather than attempting to resize it back, we simply
+	 * keep the window as-is and disable screen updates. This is done
+	 * in SDL_SetSDLWindowSurface by setting sdl.update_display_contents
+	 * to false.
+	 */
+	sdl.resizing_window = true;
+	GFX_ResetScreen();
+	sdl.resizing_window = false;
+}
+#endif
+
 void GFX_Events() {
 	//Don't poll too often. This can be heavy on the OS, especially Macs.
 	//In idle mode 3000-4000 polls are done per second without this check.
@@ -1576,6 +2444,98 @@
 #endif
 
 		switch (event.type) {
+#if SDL_VERSION_ATLEAST(2,0,0)
+		case SDL_WINDOWEVENT:
+			switch (event.window.event) {
+				case SDL_WINDOWEVENT_RESTORED:
+					/* We may need to re-create a texture
+					 * and more on Android. Another case:
+					 * Update surface while using X11.
+					 */
+					GFX_ResetScreen();
+					continue;
+				case SDL_WINDOWEVENT_RESIZED:
+					GFX_HandleVideoResize(event.window.data1, event.window.data2);
+					continue;
+				case SDL_WINDOWEVENT_EXPOSED:
+					if (sdl.draw.callback) sdl.draw.callback( GFX_CallBackRedraw );
+					continue;
+				case SDL_WINDOWEVENT_FOCUS_GAINED:
+					if (sdl.desktop.fullscreen && !sdl.mouse.locked)
+						GFX_CaptureMouse();
+					SetPriority(sdl.priority.focus);
+					CPU_Disable_SkipAutoAdjust();
+					break;
+				case SDL_WINDOWEVENT_FOCUS_LOST:
+					if (sdl.mouse.locked) {
+#ifdef WIN32
+						if (sdl.desktop.fullscreen) {
+							VGA_KillDrawing();
+							GFX_ForceFullscreenExit();
+						}
+#endif
+						GFX_CaptureMouse();
+					}
+					SetPriority(sdl.priority.nofocus);
+					GFX_LosingFocus();
+					CPU_Enable_SkipAutoAdjust();
+					break;
+				default: ;
+			}
+
+			/* Non-focus priority is set to pause; check to see if we've lost window or input focus
+			 * i.e. has the window been minimised or made inactive?
+			 */
+			if (sdl.priority.nofocus == PRIORITY_LEVEL_PAUSE) {
+				if ((event.window.event == SDL_WINDOWEVENT_FOCUS_LOST) || (event.window.event == SDL_WINDOWEVENT_MINIMIZED)) {
+					/* Window has lost focus, pause the emulator.
+					 * This is similar to what PauseDOSBox() does, but the exit criteria is different.
+					 * Instead of waiting for the user to hit Alt-Break, we wait for the window to
+					 * regain window or input focus.
+					 */
+					bool paused = true;
+					SDL_Event ev;
+
+					GFX_SetTitle(-1,-1,true);
+					KEYBOARD_ClrBuffer();
+//					SDL_Delay(500);
+//					while (SDL_PollEvent(&ev)) {
+						// flush event queue.
+//					}
+
+					while (paused) {
+						// WaitEvent waits for an event rather than polling, so CPU usage drops to zero
+						SDL_WaitEvent(&ev);
+
+						switch (ev.type) {
+						case SDL_QUIT: throw(0); break; // a bit redundant at linux at least as the active events gets before the quit event.
+						case SDL_WINDOWEVENT:     // wait until we get window focus back
+							if ((ev.window.event == SDL_WINDOWEVENT_FOCUS_LOST) || (ev.window.event == SDL_WINDOWEVENT_MINIMIZED) || (ev.window.event == SDL_WINDOWEVENT_FOCUS_GAINED) || (ev.window.event == SDL_WINDOWEVENT_RESTORED) || (ev.window.event == SDL_WINDOWEVENT_EXPOSED)) {
+								// We've got focus back, so unpause and break out of the loop
+								if ((ev.window.event == SDL_WINDOWEVENT_FOCUS_GAINED) || (ev.window.event == SDL_WINDOWEVENT_RESTORED) || (ev.window.event == SDL_WINDOWEVENT_EXPOSED)) {
+									paused = false;
+									GFX_SetTitle(-1,-1,false);
+								}
+
+								/* Now poke a "release ALT" command into the keyboard buffer
+								 * we have to do this, otherwise ALT will 'stick' and cause
+								 * problems with the app running in the DOSBox.
+								 */
+								KEYBOARD_AddKey(KBD_leftalt, false);
+								KEYBOARD_AddKey(KBD_rightalt, false);
+								if (ev.window.event == SDL_WINDOWEVENT_RESTORED) {
+									// We may need to re-create a texture and more
+									GFX_ResetScreen();
+								}
+							}
+							break;
+						}
+					}
+				}
+			}
+			break;
+#endif	// SDL_VERSION_ATLEAST(2,0,0)
+#if !SDL_VERSION_ATLEAST(2,0,0)
 		case SDL_ACTIVEEVENT:
 			if (event.active.state & SDL_APPINPUTFOCUS) {
 				if (event.active.gain) {
@@ -1649,6 +2609,14 @@
 				}
 			}
 			break;
+#endif	// !SDL_VERSION_ATLEAST(2,0,0)
+#if defined(__ANDROID__)
+		case SDL_FINGERDOWN:
+		case SDL_FINGERUP:
+		case SDL_FINGERMOTION:
+			HandleTouchFinger(&event.tfinger);
+			break;
+#else
 		case SDL_MOUSEMOTION:
 			HandleMouseMotion(&event.motion);
 			break;
@@ -1656,21 +2624,26 @@
 		case SDL_MOUSEBUTTONUP:
 			HandleMouseButton(&event.button);
 			break;
+#endif
+#if !SDL_VERSION_ATLEAST(2,0,0)
 		case SDL_VIDEORESIZE:
-//			HandleVideoResize(&event.resize);
+			//HandleVideoResize(event.resize.w, event.resize.h);
 			break;
+#endif
 		case SDL_QUIT:
 			throw(0);
 			break;
+#if !SDL_VERSION_ATLEAST(2,0,0)
 		case SDL_VIDEOEXPOSE:
 			if (sdl.draw.callback) sdl.draw.callback( GFX_CallBackRedraw );
 			break;
+#endif
 #ifdef WIN32
 		case SDL_KEYDOWN:
 		case SDL_KEYUP:
 			// ignore event alt+tab
-			if (event.key.keysym.sym==SDLK_LALT) sdl.laltstate = event.key.type;
-			if (event.key.keysym.sym==SDLK_RALT) sdl.raltstate = event.key.type;
+			if (event.key.keysym.sym==SDLK_LALT) sdl.laltstate = (SDL_EventType)event.key.type;
+			if (event.key.keysym.sym==SDLK_RALT) sdl.raltstate = (SDL_EventType)event.key.type;
 			if (((event.key.keysym.sym==SDLK_TAB)) &&
 				((sdl.laltstate==SDL_KEYDOWN) || (sdl.raltstate==SDL_KEYDOWN))) break;
 			// This can happen as well.
@@ -1682,7 +2655,15 @@
 		case SDL_KEYDOWN:
 		case SDL_KEYUP:
 			/* On macs CMD-Q is the default key to close an application */
-			if (event.key.keysym.sym == SDLK_q && (event.key.keysym.mod == KMOD_RMETA || event.key.keysym.mod == KMOD_LMETA) ) {
+			if (event.key.keysym.sym == SDLK_q &&
+#if SDL_VERSION_ATLEAST(2,0,0)
+			    (event.key.keysym.mod == KMOD_RGUI ||
+			     event.key.keysym.mod == KMOD_LGUI)
+#else
+			    (event.key.keysym.mod == KMOD_RMETA ||
+			     event.key.keysym.mod == KMOD_LMETA)
+#endif
+			    ) {
 				KillSwitch(true);
 				break;
 			}
@@ -1721,7 +2702,11 @@
 	vsprintf(buf,format,msg);
         strcat(buf,"\n");
 	va_end(msg);
+#ifdef __ANDROID__
+	__android_log_print(ANDROID_LOG_DEBUG, "DOSBox", buf);
+#else
 	if(!no_stdout) printf("%s",buf); //Else buf is parsed again.
+#endif
 }
 
 
@@ -1733,13 +2718,17 @@
 	Prop_int* Pint;
 	Prop_multival* Pmulti;
 
+#ifndef __ANDROID__
 	Pbool = sdl_sec->Add_bool("fullscreen",Property::Changeable::Always,false);
 	Pbool->Set_help("Start dosbox directly in fullscreen. (Press ALT-Enter to go back)");
+#endif
 
-	Pbool = sdl_sec->Add_bool("fulldouble",Property::Changeable::Always,false);
-	Pbool->Set_help("Use double buffering in fullscreen. It can reduce screen flickering, but it can also result in a slow DOSBox.");
+	Pbool = sdl_sec->Add_bool("vsync",Property::Changeable::Always,false);
+	Pbool->Set_help("Sync to Vblank IF supported by the output device and renderer.\n"
+	                "It can reduce screen flickering, but it can also result in a slow DOSBox.");
 
-	Pstring = sdl_sec->Add_string("fullresolution",Property::Changeable::Always,"original");
+#ifndef __ANDROID__
+	Pstring = sdl_sec->Add_string("fullresolution",Property::Changeable::Always,"0x0");
 	Pstring->Set_help("What resolution to use for fullscreen: original, desktop or a fixed size (e.g. 1024x768).\n"
 	                  "Using your monitor's native resolution with aspect=true might give the best results.\n"
 			  "If you end up with small window on a large screen, try an output different from surface."
@@ -1749,20 +2738,57 @@
 	Pstring = sdl_sec->Add_string("windowresolution",Property::Changeable::Always,"original");
 	Pstring->Set_help("Scale the window to this size IF the output device supports hardware scaling.\n"
 	                  "(output=surface does not!)");
+#endif
 
 	const char* outputs[] = {
-		"surface", "overlay",
+		"surface",
+#if SDL_VERSION_ATLEAST(2, 0, 0)
+		"texture",
+		"texturenb",
+#else	// !SDL_VERSION_ATLEAST(2, 0, 0)
+		"overlay",
+#if C_DDRAW
+		"ddraw",
+#endif
+#endif	// !SDL_VERSION_ATLEAST(2, 0, 0)
 #if C_OPENGL
 		"opengl", "openglnb",
 #endif
-#if C_DDRAW
-		"ddraw",
+		0 };
+#if SDL_VERSION_ATLEAST(2, 0, 0)
+#if C_OPENGL && defined(MACOSX)
+	Pstring = sdl_sec->Add_string("output",Property::Changeable::Always,"opengl");
+#else
+	Pstring = sdl_sec->Add_string("output",Property::Changeable::Always,"texture");
 #endif
-		0 };
+#else
 	Pstring = sdl_sec->Add_string("output",Property::Changeable::Always,"surface");
+#endif
 	Pstring->Set_help("What video system to use for output.");
 	Pstring->Set_values(outputs);
 
+#if SDL_VERSION_ATLEAST(2,0,0)
+	const char* renderers[] = {
+		"auto",
+#ifdef WIN32
+		"direct3d",
+#endif
+#ifdef __ANDROID__
+		"opengles2",
+		"opengles",
+#else	// On any platform other than Android
+		"opengl",
+#endif
+#ifdef MACOSX
+		"metal",
+#endif
+		"software",
+		0 };
+	Pstring = sdl_sec->Add_string("renderer",Property::Changeable::Always,"auto");
+	Pstring->Set_help("Choose a renderer driver if output=texture or output=texturenb. Use output=auto for an automatic choice.");
+	Pstring->Set_values(renderers);
+#endif	// SDL_VERSION_ATLEAST(2,0,0)
+
 	Pbool = sdl_sec->Add_bool("autolock",Property::Changeable::Always,true);
 	Pbool->Set_help("Mouse will automatically lock, if you click on the screen. (Press CTRL-F10 to unlock)");
 
@@ -1793,8 +2819,10 @@
 	Pstring = sdl_sec->Add_path("mapperfile",Property::Changeable::Always,MAPPERFILE);
 	Pstring->Set_help("File used to load/save the key/event mappings from. Resetmapper only works with the default value.");
 
+#if !SDL_VERSION_ATLEAST(2,0,0)
 	Pbool = sdl_sec->Add_bool("usescancodes",Property::Changeable::Always,true);
 	Pbool->Set_help("Avoid usage of symkeys, might not work on all operating systems.");
+#endif
 }
 
 static void show_warning(char const * const message) {
@@ -1806,8 +2834,15 @@
 #endif
 	printf("%s",message);
 	if(textonly) return;
+#if SDL_VERSION_ATLEAST(2, 0, 0)
+	if (!sdl.window)
+		if (!GFX_SetSDLSurfaceWindow(640,400)) return;
+	sdl.surface = SDL_GetWindowSurface(sdl.window);
+#else
 	if(!sdl.surface) sdl.surface = SDL_SetVideoMode_Wrap(640,400,0,0);
+#endif
 	if(!sdl.surface) return;
+
 #if SDL_BYTEORDER == SDL_BIG_ENDIAN
 	Bit32u rmask = 0xff000000;
 	Bit32u gmask = 0x00ff0000;
@@ -1835,7 +2870,11 @@
 	}
 
 	SDL_BlitSurface(splash_surf, NULL, sdl.surface, NULL);
+#if SDL_VERSION_ATLEAST(2, 0, 0)
+	SDL_UpdateWindowSurface(sdl.window);
+#else
 	SDL_Flip(sdl.surface);
+#endif
 	SDL_Delay(12000);
 }
 
@@ -1865,6 +2904,8 @@
 extern void DEBUG_ShutDown(Section * /*sec*/);
 #endif
 
+void MIXER_CloseAudioDevice(void);
+
 void restart_program(std::vector<std::string> & parameters) {
 	char** newargs = new char* [parameters.size() + 1];
 	// parameter 0 is the executable path
@@ -1872,9 +2913,9 @@
 	// last one is NULL
 	for(Bitu i = 0; i < parameters.size(); i++) newargs[i] = (char*)parameters[i].c_str();
 	newargs[parameters.size()] = NULL;
-	SDL_CloseAudio();
+	MIXER_CloseAudioDevice();
 	SDL_Delay(50);
-	SDL_Quit();
+	SDL_Quit_Wrapper();
 #if C_DEBUG
 	// shutdown curses
 	DEBUG_ShutDown(NULL);
@@ -2058,14 +3099,16 @@
 	 */
 	putenv(const_cast<char*>("SDL_DISABLE_LOCK_KEYS=1"));
 #endif
-	// Don't init timers, GetTicks seems to work fine and they can use a fair amount of power (Macs again) 
-	// Please report problems with audio and other things.
-	if ( SDL_Init( SDL_INIT_AUDIO|SDL_INIT_VIDEO | /*SDL_INIT_TIMER |*/ SDL_INIT_CDROM
-		|SDL_INIT_NOPARACHUTE
-		) < 0 ) E_Exit("Can't init SDL %s",SDL_GetError());
+	if ( SDL_Init_Wrapper() < 0 )
+		E_Exit("Can't init SDL %s",SDL_GetError());
 	sdl.inited = true;
 
 #ifndef DISABLE_JOYSTICK
+#ifdef __ANDROID__
+	// Disable accelerometer-as-joystick emulation
+	// (available for backwards compatibility)
+	SDL_SetHint(SDL_HINT_ACCELEROMETER_AS_JOYSTICK, "0");
+#endif
 	//Initialise Joystick separately. This way we can warn when it fails instead
 	//of exiting the application
 	if( SDL_InitSubSystem(SDL_INIT_JOYSTICK) < 0 ) LOG_MSG("Failed to init joystick support");
@@ -2074,6 +3117,7 @@
 	sdl.laltstate = SDL_KEYUP;
 	sdl.raltstate = SDL_KEYUP;
 
+#if !SDL_VERSION_ATLEAST(2, 0, 0) // Not relevant for SDL 2.0 at the moment
 #if defined (WIN32)
 #if SDL_VERSION_ATLEAST(1, 2, 10)
 		sdl.using_windib=true;
@@ -2102,7 +3146,8 @@
 		if (SDL_VideoDriverName(sdl_drv_name,128)!=NULL) {
 			if (strcmp(sdl_drv_name,"windib")==0) LOG_MSG("SDL_Init: Starting up with SDL windib video driver.\n          Try to update your video card and directx drivers!");
 		}
-#endif
+#endif	// WIN32
+#endif	// !SDL_VERSION_ATLEAST(2, 0, 0)
 	sdl.num_joysticks=SDL_NumJoysticks();
 
 	/* Parse configuration files */
@@ -2215,10 +3260,17 @@
 	sticky_keys(true); //Might not be needed if the shutdown function switches to windowed mode, but it doesn't hurt
 #endif
 	//Force visible mouse to end user. Somehow this sometimes doesn't happen
+#if SDL_VERSION_ATLEAST(2,0,0)
+	SDL_SetRelativeMouseMode(SDL_FALSE);
+#else
 	SDL_WM_GrabInput(SDL_GRAB_OFF);
+#endif
 	SDL_ShowCursor(SDL_ENABLE);
 
-	SDL_Quit();//Let's hope sdl will quit as well when it catches an exception
+	SDL_Quit_Wrapper();//Let's hope sdl will quit as well when it catches an exception
+#ifdef __ANDROID__
+	exit(0); // Actually quits application... and hopefully(?) removes static values
+#endif
 	return 0;
 }
 
Index: src/hardware/mixer.cpp
===================================================================
--- src/hardware/mixer.cpp	(revision 4281)
+++ src/hardware/mixer.cpp	(working copy)
@@ -86,6 +86,10 @@
 	bool nosound;
 	Bit32u freq;
 	Bit32u blocksize;
+#if SDL_VERSION_ATLEAST(2,0,0)
+	//Note: As stated earlier, all sdl code shall rather be in sdlmain
+	SDL_AudioDeviceID sdldevice;
+#endif
 } mixer;
 
 Bit8u MixTemp[MIXER_BUFSIZE];
@@ -127,6 +131,22 @@
 	}
 }
 
+static void MIXER_LockAudioDevice(void) {
+#if SDL_VERSION_ATLEAST(2,0,0)
+	SDL_LockAudioDevice(mixer.sdldevice);
+#else
+	SDL_LockAudio();
+#endif
+}
+
+static void MIXER_UnlockAudioDevice(void) {
+#if SDL_VERSION_ATLEAST(2,0,0)
+	SDL_UnlockAudioDevice(mixer.sdldevice);
+#else
+	SDL_UnlockAudio();
+#endif
+}
+
 void MixerChannel::UpdateVolume(void) {
 	volmul[0]=(Bits)((1 << MIXER_VOLSHIFT)*scale*volmain[0]*mixer.mastervol[0]);
 	volmul[1]=(Bits)((1 << MIXER_VOLSHIFT)*scale*volmain[1]*mixer.mastervol[1]);
@@ -148,9 +168,9 @@
 	enabled=_yesno;
 	if (enabled) {
 		freq_counter = 0;
-		SDL_LockAudio();
+		MIXER_LockAudioDevice();
 		if (done<mixer.done) done=mixer.done;
-		SDL_UnlockAudio();
+		MIXER_UnlockAudioDevice();
 	}
 }
 
@@ -382,14 +402,14 @@
 }
 
 void MixerChannel::FillUp(void) {
-	SDL_LockAudio();
+	MIXER_LockAudioDevice();
 	if (!enabled || done<mixer.done) {
-		SDL_UnlockAudio();
+		MIXER_UnlockAudioDevice();
 		return;
 	}
 	float index=PIC_TickIndex();
 	Mix((Bitu)(index*mixer.needed));
-	SDL_UnlockAudio();
+	MIXER_UnlockAudioDevice();
 }
 
 extern bool ticksLocked;
@@ -439,12 +459,12 @@
 }
 
 static void MIXER_Mix(void) {
-	SDL_LockAudio();
+	MIXER_LockAudioDevice();
 	MIXER_MixData(mixer.needed);
 	mixer.tick_counter += mixer.tick_add;
 	mixer.needed+=(mixer.tick_counter >> TICK_SHIFT);
 	mixer.tick_counter &= TICK_MASK;
-	SDL_UnlockAudio();
+	MIXER_UnlockAudioDevice();
 }
 
 static void MIXER_Mix_NoSound(void) {
@@ -468,6 +488,9 @@
 }
 
 static void SDLCALL MIXER_CallBack(void * userdata, Uint8 *stream, int len) {
+#if SDL_VERSION_ATLEAST(2,0,0)
+	memset(stream, 0, len);
+#endif
 	Bitu need=(Bitu)len/MIXER_SSIZE;
 	Bit16s * output=(Bit16s *)stream;
 	Bitu reduce;
@@ -696,7 +719,11 @@
 		LOG_MSG("MIXER: No Sound Mode Selected.");
 		mixer.tick_add=calc_tickadd(mixer.freq);
 		TIMER_AddTickHandler(MIXER_Mix_NoSound);
+#if SDL_VERSION_ATLEAST(2,0,0)
+	} else if ((mixer.sdldevice = SDL_OpenAudioDevice(NULL, 0, &spec, &obtained, SDL_AUDIO_ALLOW_FREQUENCY_CHANGE)) ==0 ) {
+#else
 	} else if (SDL_OpenAudio(&spec, &obtained) <0 ) {
+#endif
 		mixer.nosound = true;
 		LOG_MSG("MIXER: Can't open audio: %s , running in nosound mode.",SDL_GetError());
 		mixer.tick_add=calc_tickadd(mixer.freq);
@@ -708,7 +735,11 @@
 		mixer.blocksize=obtained.samples;
 		mixer.tick_add=calc_tickadd(mixer.freq);
 		TIMER_AddTickHandler(MIXER_Mix);
+#if SDL_VERSION_ATLEAST(2,0,0)
+		SDL_PauseAudioDevice(mixer.sdldevice, 0);
+#else
 		SDL_PauseAudio(0);
+#endif
 	}
 	mixer.min_needed=section->Get_int("prebuffer");
 	if (mixer.min_needed>100) mixer.min_needed=100;
@@ -717,3 +748,16 @@
 	mixer.needed=mixer.min_needed+1;
 	PROGRAMS_MakeFile("MIXER.COM",MIXER_ProgramStart);
 }
+
+void MIXER_CloseAudioDevice(void) {
+	if (!mixer.nosound) {
+#if SDL_VERSION_ATLEAST(2,0,0)
+		if (mixer.sdldevice != 0) {
+			SDL_CloseAudioDevice(mixer.sdldevice);
+			mixer.sdldevice = 0;
+		}
+#else
+		SDL_CloseAudio();
+#endif
+	}
+}
Index: src/misc/cross.cpp
===================================================================
--- src/misc/cross.cpp	(revision 4281)
+++ src/misc/cross.cpp	(working copy)
@@ -31,6 +31,10 @@
 #include <shlobj.h>
 #endif
 
+#if defined(__ANDROID__)
+#include "SDL_system.h" // For SDL_AndroidGetExternalStoragePath
+#endif
+
 #if defined HAVE_SYS_TYPES_H && defined HAVE_PWD_H
 #include <sys/types.h>
 #include <pwd.h>
@@ -62,6 +66,10 @@
 #elif defined(MACOSX)
 	in = "~/Library/Preferences";
 	ResolveHomedir(in);
+#elif defined(__ANDROID__)
+	in = SDL_AndroidGetExternalStoragePath();
+	//Assume external storage (possibly internal) is available
+	ResolveHomedir(in);
 #else
 	in = "~/.dosbox";
 	ResolveHomedir(in);
@@ -89,6 +97,11 @@
 	in = "~/Library/Preferences";
 	ResolveHomedir(in);
 	//Don't create it. Assume it exists
+#elif defined(__ANDROID__)
+	in = SDL_AndroidGetExternalStoragePath();
+	//Assume external storage (possibly internal) is available
+	ResolveHomedir(in);
+	mkdir(in.c_str(),0770);
 #else
 	in = "~/.dosbox";
 	ResolveHomedir(in);
